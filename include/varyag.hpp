// Generated by Varyag generate-hpp tool

#pragma once

#include "varyag.h"
#include <cstddef>
#include <cstring>
#include <compare>
#include <array>

namespace vg
{
	using ShaderModule = VgShaderModule;
	using Fence = VgFence;
	using Sampler = VgSampler;
	using Surface = VgSurface;
	using View = VgView;
	using AttachmentView = VgAttachmentView;

	class Adapter;
	class Device;
	class CommandPool;
	class CommandList;
	class Cmd;
	class Buffer;
	class Pipeline;
	class Texture;
	class SwapChain;

	static constexpr uint32_t numAllowedRootConstants = vg_num_allowed_root_constants;
	static constexpr uint32_t numMaxViewportsAndScissors = vg_num_max_viewports_and_scissors;
	static constexpr uint32_t numMaxColorAttachments = vg_num_max_color_attachments;
	static constexpr uint32_t numMaxAdapterNameLength = vg_num_max_adapter_name_length;
	static constexpr uint32_t numMaxVertexBuffers = vg_num_max_vertex_buffers;
	static constexpr uint32_t numMaxVertexAttributes = vg_num_max_vertex_attributes;

	enum class GraphicsApi : uint64_t
	{
		Auto   = VG_GRAPHICS_API_AUTO,
		D3d12  = VG_GRAPHICS_API_D3D12,
		Vulkan = VG_GRAPHICS_API_VULKAN,
	};

	enum class Result : uint64_t
	{
		Success            = VG_SUCCESS,
		ApiUnsupported     = VG_API_UNSUPPORTED,
		BadArgument        = VG_BAD_ARGUMENT,
		AlreadyInitialized = VG_ALREADY_INITIALIZED,
		Failure            = VG_FAILURE,
		IllegalOperation   = VG_ILLEGAL_OPERATION,
		DeviceLost         = VG_DEVICE_LOST,
	};

	enum class MessageSeverity : uint64_t
	{
		Info  = VG_MESSAGE_SEVERITY_INFO,
		Debug = VG_MESSAGE_SEVERITY_DEBUG,
		Warn  = VG_MESSAGE_SEVERITY_WARN,
		Error = VG_MESSAGE_SEVERITY_ERROR,
	};

	enum class AdapterType : uint64_t
	{
		Discrete   = VG_ADAPTER_TYPE_DISCRETE,
		Integrated = VG_ADAPTER_TYPE_INTEGRATED,
		Software   = VG_ADAPTER_TYPE_SOFTWARE,
	};

	enum class Queue : uint64_t
	{
		Graphics = VG_QUEUE_GRAPHICS,
		Compute  = VG_QUEUE_COMPUTE,
		Transfer = VG_QUEUE_TRANSFER,
	};

	enum class Format : uint64_t
	{
		Unknown                = VG_FORMAT_UNKNOWN,
		R32g32b32a32Typeless   = VG_FORMAT_R32G32B32A32_TYPELESS,
		R32g32b32a32Float      = VG_FORMAT_R32G32B32A32_FLOAT,
		R32g32b32a32Uint       = VG_FORMAT_R32G32B32A32_UINT,
		R32g32b32a32Sint       = VG_FORMAT_R32G32B32A32_SINT,
		R32g32b32Typeless      = VG_FORMAT_R32G32B32_TYPELESS,
		R32g32b32Float         = VG_FORMAT_R32G32B32_FLOAT,
		R32g32b32Uint          = VG_FORMAT_R32G32B32_UINT,
		R32g32b32Sint          = VG_FORMAT_R32G32B32_SINT,
		R16g16b16a16Typeless   = VG_FORMAT_R16G16B16A16_TYPELESS,
		R16g16b16a16Float      = VG_FORMAT_R16G16B16A16_FLOAT,
		R16g16b16a16Unorm      = VG_FORMAT_R16G16B16A16_UNORM,
		R16g16b16a16Uint       = VG_FORMAT_R16G16B16A16_UINT,
		R16g16b16a16Snorm      = VG_FORMAT_R16G16B16A16_SNORM,
		R16g16b16a16Sint       = VG_FORMAT_R16G16B16A16_SINT,
		R32g32Typeless         = VG_FORMAT_R32G32_TYPELESS,
		R32g32Float            = VG_FORMAT_R32G32_FLOAT,
		R32g32Uint             = VG_FORMAT_R32G32_UINT,
		R32g32Sint             = VG_FORMAT_R32G32_SINT,
		R32g8x24Typeless       = VG_FORMAT_R32G8X24_TYPELESS,
		D32FloatS8x24Uint      = VG_FORMAT_D32_FLOAT_S8X24_UINT,
		R32FloatX8x24Typeless  = VG_FORMAT_R32_FLOAT_X8X24_TYPELESS,
		X32TypelessG8x24Uint   = VG_FORMAT_X32_TYPELESS_G8X24_UINT,
		R10g10b10a2Typeless    = VG_FORMAT_R10G10B10A2_TYPELESS,
		R10g10b10a2Unorm       = VG_FORMAT_R10G10B10A2_UNORM,
		R10g10b10a2Uint        = VG_FORMAT_R10G10B10A2_UINT,
		R11g11b10Float         = VG_FORMAT_R11G11B10_FLOAT,
		R8g8b8a8Typeless       = VG_FORMAT_R8G8B8A8_TYPELESS,
		R8g8b8a8Unorm          = VG_FORMAT_R8G8B8A8_UNORM,
		R8g8b8a8Srgb           = VG_FORMAT_R8G8B8A8_SRGB,
		R8g8b8a8Uint           = VG_FORMAT_R8G8B8A8_UINT,
		R8g8b8a8Snorm          = VG_FORMAT_R8G8B8A8_SNORM,
		R8g8b8a8Sint           = VG_FORMAT_R8G8B8A8_SINT,
		R16g16Typeless         = VG_FORMAT_R16G16_TYPELESS,
		R16g16Float            = VG_FORMAT_R16G16_FLOAT,
		R16g16Unorm            = VG_FORMAT_R16G16_UNORM,
		R16g16Uint             = VG_FORMAT_R16G16_UINT,
		R16g16Snorm            = VG_FORMAT_R16G16_SNORM,
		R16g16Sint             = VG_FORMAT_R16G16_SINT,
		R32Typeless            = VG_FORMAT_R32_TYPELESS,
		D32Float               = VG_FORMAT_D32_FLOAT,
		R32Float               = VG_FORMAT_R32_FLOAT,
		R32Uint                = VG_FORMAT_R32_UINT,
		R32Sint                = VG_FORMAT_R32_SINT,
		R24g8Typeless          = VG_FORMAT_R24G8_TYPELESS,
		D24UnormS8Uint         = VG_FORMAT_D24_UNORM_S8_UINT,
		R24UnormX8Typeless     = VG_FORMAT_R24_UNORM_X8_TYPELESS,
		X24TypelessG8Uint      = VG_FORMAT_X24_TYPELESS_G8_UINT,
		R8g8Typeless           = VG_FORMAT_R8G8_TYPELESS,
		R8g8Unorm              = VG_FORMAT_R8G8_UNORM,
		R8g8Uint               = VG_FORMAT_R8G8_UINT,
		R8g8Snorm              = VG_FORMAT_R8G8_SNORM,
		R8g8Sint               = VG_FORMAT_R8G8_SINT,
		R16Typeless            = VG_FORMAT_R16_TYPELESS,
		R16Float               = VG_FORMAT_R16_FLOAT,
		D16Unorm               = VG_FORMAT_D16_UNORM,
		R16Unorm               = VG_FORMAT_R16_UNORM,
		R16Uint                = VG_FORMAT_R16_UINT,
		R16Snorm               = VG_FORMAT_R16_SNORM,
		R16Sint                = VG_FORMAT_R16_SINT,
		R8Typeless             = VG_FORMAT_R8_TYPELESS,
		R8Unorm                = VG_FORMAT_R8_UNORM,
		R8Uint                 = VG_FORMAT_R8_UINT,
		R8Snorm                = VG_FORMAT_R8_SNORM,
		R8Sint                 = VG_FORMAT_R8_SINT,
		A8Unorm                = VG_FORMAT_A8_UNORM,
		R1Unorm                = VG_FORMAT_R1_UNORM,
		R9g9b9e5Sharedexp      = VG_FORMAT_R9G9B9E5_SHAREDEXP,
		R8g8B8g8Unorm          = VG_FORMAT_R8G8_B8G8_UNORM,
		G8r8G8b8Unorm          = VG_FORMAT_G8R8_G8B8_UNORM,
		Bc1Typeless            = VG_FORMAT_BC1_TYPELESS,
		Bc1Unorm               = VG_FORMAT_BC1_UNORM,
		Bc1Srgb                = VG_FORMAT_BC1_SRGB,
		Bc2Typeless            = VG_FORMAT_BC2_TYPELESS,
		Bc2Unorm               = VG_FORMAT_BC2_UNORM,
		Bc2Srgb                = VG_FORMAT_BC2_SRGB,
		Bc3Typeless            = VG_FORMAT_BC3_TYPELESS,
		Bc3Unorm               = VG_FORMAT_BC3_UNORM,
		Bc3Srgb                = VG_FORMAT_BC3_SRGB,
		Bc4Typeless            = VG_FORMAT_BC4_TYPELESS,
		Bc4Unorm               = VG_FORMAT_BC4_UNORM,
		Bc4Snorm               = VG_FORMAT_BC4_SNORM,
		Bc5Typeless            = VG_FORMAT_BC5_TYPELESS,
		Bc5Unorm               = VG_FORMAT_BC5_UNORM,
		Bc5Snorm               = VG_FORMAT_BC5_SNORM,
		B5g6r5Unorm            = VG_FORMAT_B5G6R5_UNORM,
		B5g5r5a1Unorm          = VG_FORMAT_B5G5R5A1_UNORM,
		B8g8r8a8Unorm          = VG_FORMAT_B8G8R8A8_UNORM,
		B8g8r8x8Unorm          = VG_FORMAT_B8G8R8X8_UNORM,
		R10g10b10XrBiasA2Unorm = VG_FORMAT_R10G10B10_XR_BIAS_A2_UNORM,
		B8g8r8a8Typeless       = VG_FORMAT_B8G8R8A8_TYPELESS,
		B8g8r8a8Srgb           = VG_FORMAT_B8G8R8A8_SRGB,
		B8g8r8x8Typeless       = VG_FORMAT_B8G8R8X8_TYPELESS,
		B8g8r8x8Srgb           = VG_FORMAT_B8G8R8X8_SRGB,
		Bc6hTypeless           = VG_FORMAT_BC6H_TYPELESS,
		Bc6hUf16               = VG_FORMAT_BC6H_UF16,
		Bc6hSf16               = VG_FORMAT_BC6H_SF16,
		Bc7Typeless            = VG_FORMAT_BC7_TYPELESS,
		Bc7Unorm               = VG_FORMAT_BC7_UNORM,
		Bc7Srgb                = VG_FORMAT_BC7_SRGB,
	};

	enum class HeapType : uint64_t
	{
		Gpu      = VG_HEAP_TYPE_GPU,
		Upload   = VG_HEAP_TYPE_UPLOAD,
		Readback = VG_HEAP_TYPE_READBACK,
	};

	enum class BufferUsage : uint64_t
	{
		General  = VG_BUFFER_USAGE_GENERAL,
		Constant = VG_BUFFER_USAGE_CONSTANT,
	};

	enum class InitFlags : uint64_t
	{
		None                  = VG_INIT_NONE,
		Debug                 = VG_INIT_DEBUG,
		EnableMessageCallback = VG_INIT_ENABLE_MESSAGE_CALLBACK,
		UseProvidedAllocator  = VG_INIT_USE_PROVIDED_ALLOCATOR,
	};

	enum class IndexType : uint64_t
	{
		Uint16 = VG_INDEX_TYPE_UINT16,
		Uint32 = VG_INDEX_TYPE_UINT32,
	};

	enum class PipelineType : uint64_t
	{
		Graphics = VG_PIPELINE_TYPE_GRAPHICS,
		Compute  = VG_PIPELINE_TYPE_COMPUTE,
	};

	enum class BufferDescriptorType : uint64_t
	{
		Srv = VG_BUFFER_DESCRIPTOR_TYPE_SRV,
		Uav = VG_BUFFER_DESCRIPTOR_TYPE_UAV,
		Cbv = VG_BUFFER_DESCRIPTOR_TYPE_CBV,
	};

	enum class BufferViewType : uint64_t
	{
		Buffer            = VG_BUFFER_VIEW_TYPE_BUFFER,
		StructuredBuffer  = VG_BUFFER_VIEW_TYPE_STRUCTURED_BUFFER,
		ByteAddressBuffer = VG_BUFFER_VIEW_TYPE_BYTE_ADDRESS_BUFFER,
	};

	enum class CommandPoolFlags : uint64_t
	{
		FlagNone      = VG_COMMAND_POOL_FLAG_NONE,
		FlagTransient = VG_COMMAND_POOL_FLAG_TRANSIENT,
	};

	enum class PipelineStageFlags : uint64_t
	{
		None                         = VG_PIPELINE_STAGE_NONE,
		TopOfPipe                    = VG_PIPELINE_STAGE_TOP_OF_PIPE,
		DrawIndirect                 = VG_PIPELINE_STAGE_DRAW_INDIRECT,
		VertexInput                  = VG_PIPELINE_STAGE_VERTEX_INPUT,
		VertexShader                 = VG_PIPELINE_STAGE_VERTEX_SHADER,
		TessellationControlShader    = VG_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER,
		TessellationEvaluationShader = VG_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER,
		GeometryShader               = VG_PIPELINE_STAGE_GEOMETRY_SHADER,
		FragmentShader               = VG_PIPELINE_STAGE_FRAGMENT_SHADER,
		EarlyFragmentTests           = VG_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS,
		LateFragmentTests            = VG_PIPELINE_STAGE_LATE_FRAGMENT_TESTS,
		ColorAttachmentOutput        = VG_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT,
		ComputeShader                = VG_PIPELINE_STAGE_COMPUTE_SHADER,
		AllTransfer                  = VG_PIPELINE_STAGE_ALL_TRANSFER,
		Transfer                     = VG_PIPELINE_STAGE_TRANSFER,
		BottomOfPipe                 = VG_PIPELINE_STAGE_BOTTOM_OF_PIPE,
		AllGraphics                  = VG_PIPELINE_STAGE_ALL_GRAPHICS,
		AllCommands                  = VG_PIPELINE_STAGE_ALL_COMMANDS,
		Resolve                      = VG_PIPELINE_STAGE_RESOLVE,
		Blit                         = VG_PIPELINE_STAGE_BLIT,
		Clear                        = VG_PIPELINE_STAGE_CLEAR,
		IndexInput                   = VG_PIPELINE_STAGE_INDEX_INPUT,
		VertexAttributeInput         = VG_PIPELINE_STAGE_VERTEX_ATTRIBUTE_INPUT,
		PreRasterizationShaders      = VG_PIPELINE_STAGE_PRE_RASTERIZATION_SHADERS,
		AccelerationStructureBuild   = VG_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD,
		AccelerationStructureCopy    = VG_PIPELINE_STAGE_ACCELERATION_STRUCTURE_COPY,
		RayTracingShader             = VG_PIPELINE_STAGE_RAY_TRACING_SHADER,
		TaskShader                   = VG_PIPELINE_STAGE_TASK_SHADER,
		MeshShader                   = VG_PIPELINE_STAGE_MESH_SHADER,
	};

	enum class AccessFlags : uint64_t
	{
		None                        = VG_ACCESS_NONE,
		IndirectCommandRead         = VG_ACCESS_INDIRECT_COMMAND_READ,
		IndexRead                   = VG_ACCESS_INDEX_READ,
		VertexAttributeRead         = VG_ACCESS_VERTEX_ATTRIBUTE_READ,
		UniformRead                 = VG_ACCESS_UNIFORM_READ,
		InputAttachmentRead         = VG_ACCESS_INPUT_ATTACHMENT_READ,
		ShaderRead                  = VG_ACCESS_SHADER_READ,
		ShaderWrite                 = VG_ACCESS_SHADER_WRITE,
		ColorAttachmentRead         = VG_ACCESS_COLOR_ATTACHMENT_READ,
		ColorAttachmentWrite        = VG_ACCESS_COLOR_ATTACHMENT_WRITE,
		DepthStencilAttachmentRead  = VG_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ,
		DepthStencilAttachmentWrite = VG_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE,
		TransferRead                = VG_ACCESS_TRANSFER_READ,
		TransferWrite               = VG_ACCESS_TRANSFER_WRITE,
		MemoryRead                  = VG_ACCESS_MEMORY_READ,
		MemoryWrite                 = VG_ACCESS_MEMORY_WRITE,
		ShaderSampledRead           = VG_ACCESS_SHADER_SAMPLED_READ,
		ShaderStorageRead           = VG_ACCESS_SHADER_STORAGE_READ,
		ShaderStorageWrite          = VG_ACCESS_SHADER_STORAGE_WRITE,
		AccelerationStructureRead   = VG_ACCESS_ACCELERATION_STRUCTURE_READ,
		AccelerationStructureWrite  = VG_ACCESS_ACCELERATION_STRUCTURE_WRITE,
		ShaderBindingTableRead      = VG_ACCESS_SHADER_BINDING_TABLE_READ,
	};

	enum class Filter : uint64_t
	{
		Nearest = VG_FILTER_NEAREST,
		Linear  = VG_FILTER_LINEAR,
	};

	enum class MipmapMode : uint64_t
	{
		Nearest = VG_MIPMAP_MODE_NEAREST,
		Linear  = VG_MIPMAP_MODE_LINEAR,
	};

	enum class AddressMode : uint64_t
	{
		Repeat         = VG_ADDRESS_MODE_REPEAT,
		MirroredRepeat = VG_ADDRESS_MODE_MIRRORED_REPEAT,
		ClampToEdge    = VG_ADDRESS_MODE_CLAMP_TO_EDGE,
		ClampToBorder  = VG_ADDRESS_MODE_CLAMP_TO_BORDER,
		MirrorOnce     = VG_ADDRESS_MODE_MIRROR_ONCE,
	};

	enum class Anisotropy : uint64_t
	{
		e1  = VG_ANISOTROPY_1,
		e2  = VG_ANISOTROPY_2,
		e4  = VG_ANISOTROPY_4,
		e8  = VG_ANISOTROPY_8,
		e16 = VG_ANISOTROPY_16,
	};

	enum class ComparisonFunc : uint64_t
	{
		None         = VG_COMPARISON_FUNC_NONE,
		Never        = VG_COMPARISON_FUNC_NEVER,
		Less         = VG_COMPARISON_FUNC_LESS,
		Equal        = VG_COMPARISON_FUNC_EQUAL,
		LessEqual    = VG_COMPARISON_FUNC_LESS_EQUAL,
		Greater      = VG_COMPARISON_FUNC_GREATER,
		NotEqual     = VG_COMPARISON_FUNC_NOT_EQUAL,
		GreaterEqual = VG_COMPARISON_FUNC_GREATER_EQUAL,
		Always       = VG_COMPARISON_FUNC_ALWAYS,
	};

	enum class ReductionMode : uint64_t
	{
		Default = VG_REDUCTION_MODE_DEFAULT,
		Min     = VG_REDUCTION_MODE_MIN,
		Max     = VG_REDUCTION_MODE_MAX,
	};

	enum class TextureLayout : uint64_t
	{
		Undefined            = VG_TEXTURE_LAYOUT_UNDEFINED,
		General              = VG_TEXTURE_LAYOUT_GENERAL,
		ColorAttachment      = VG_TEXTURE_LAYOUT_COLOR_ATTACHMENT,
		DepthStencil         = VG_TEXTURE_LAYOUT_DEPTH_STENCIL,
		DepthStencilReadOnly = VG_TEXTURE_LAYOUT_DEPTH_STENCIL_READ_ONLY,
		ShaderResource       = VG_TEXTURE_LAYOUT_SHADER_RESOURCE,
		TransferSource       = VG_TEXTURE_LAYOUT_TRANSFER_SOURCE,
		TransferDest         = VG_TEXTURE_LAYOUT_TRANSFER_DEST,
		ResolveSource        = VG_TEXTURE_LAYOUT_RESOLVE_SOURCE,
		ResolveDest          = VG_TEXTURE_LAYOUT_RESOLVE_DEST,
		Present              = VG_TEXTURE_LAYOUT_PRESENT,
		ReadOnly             = VG_TEXTURE_LAYOUT_READ_ONLY,
		UnorderedAccess      = VG_TEXTURE_LAYOUT_UNORDERED_ACCESS,
	};

	enum class TextureType : uint64_t
	{
		e1d = VG_TEXTURE_TYPE_1D,
		e2d = VG_TEXTURE_TYPE_2D,
		e3d = VG_TEXTURE_TYPE_3D,
	};

	enum class SampleCount : uint64_t
	{
		e1 = VG_SAMPLE_COUNT_1,
		e2 = VG_SAMPLE_COUNT_2,
		e4 = VG_SAMPLE_COUNT_4,
		e8 = VG_SAMPLE_COUNT_8,
	};

	enum class TextureUsageFlags : uint64_t
	{
		ShaderResource          = VG_TEXTURE_USAGE_SHADER_RESOURCE,
		UnorderedAccess         = VG_TEXTURE_USAGE_UNORDERED_ACCESS,
		ColorAttachment         = VG_TEXTURE_USAGE_COLOR_ATTACHMENT,
		DepthStencilAttachment  = VG_TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT,
		AllowSimultaneousAccess = VG_TEXTURE_USAGE_ALLOW_SIMULTANEOUS_ACCESS,
	};

	enum class TextureTiling : uint64_t
	{
		Optimal = VG_TEXTURE_TILING_OPTIMAL,
		Linear  = VG_TEXTURE_TILING_LINEAR,
	};

	enum class TextureAttachmentViewType : uint64_t
	{
		e1d        = VG_TEXTURE_ATTACHMENT_VIEW_TYPE_1D,
		e1dArray   = VG_TEXTURE_ATTACHMENT_VIEW_TYPE_1D_ARRAY,
		e2d        = VG_TEXTURE_ATTACHMENT_VIEW_TYPE_2D,
		e2dArray   = VG_TEXTURE_ATTACHMENT_VIEW_TYPE_2D_ARRAY,
		e2dMs      = VG_TEXTURE_ATTACHMENT_VIEW_TYPE_2D_MS,
		e2dMsArray = VG_TEXTURE_ATTACHMENT_VIEW_TYPE_2D_MS_ARRAY,
		e3d        = VG_TEXTURE_ATTACHMENT_VIEW_TYPE_3D,
	};

	enum class TextureViewType : uint64_t
	{
		e1d        = VG_TEXTURE_VIEW_TYPE_1D,
		e1dArray   = VG_TEXTURE_VIEW_TYPE_1D_ARRAY,
		e2d        = VG_TEXTURE_VIEW_TYPE_2D,
		e2dArray   = VG_TEXTURE_VIEW_TYPE_2D_ARRAY,
		e2dMs      = VG_TEXTURE_VIEW_TYPE_2D_MS,
		e2dMsArray = VG_TEXTURE_VIEW_TYPE_2D_MS_ARRAY,
		e3d        = VG_TEXTURE_VIEW_TYPE_3D,
		Cube       = VG_TEXTURE_VIEW_TYPE_CUBE,
		CubeArray  = VG_TEXTURE_VIEW_TYPE_CUBE_ARRAY,
	};

	enum class TextureAspect : uint64_t
	{
		Color   = VG_TEXTURE_ASPECT_COLOR,
		Depth   = VG_TEXTURE_ASPECT_DEPTH,
		Stencil = VG_TEXTURE_ASPECT_STENCIL,
	};

	enum class ResolveMode : uint64_t
	{
		Average = VG_RESOLVE_MODE_AVERAGE,
		Min     = VG_RESOLVE_MODE_MIN,
		Max     = VG_RESOLVE_MODE_MAX,
	};

	enum class AttachmentOp : uint64_t
	{
		Default  = VG_ATTACHMENT_OP_DEFAULT,
		Clear    = VG_ATTACHMENT_OP_CLEAR,
		DontCare = VG_ATTACHMENT_OP_DONT_CARE,
	};

	enum class TextureDescriptorType : uint64_t
	{
		Srv = VG_TEXTURE_DESCRIPTOR_TYPE_SRV,
		Uav = VG_TEXTURE_DESCRIPTOR_TYPE_UAV,
	};

	enum class ComponentMapping : uint64_t
	{
		Identity = VG_COMPONENT_MAPPING_IDENTITY,
		Zero     = VG_COMPONENT_MAPPING_ZERO,
		One      = VG_COMPONENT_MAPPING_ONE,
		R        = VG_COMPONENT_MAPPING_R,
		G        = VG_COMPONENT_MAPPING_G,
		B        = VG_COMPONENT_MAPPING_B,
		A        = VG_COMPONENT_MAPPING_A,
	};

	enum class VertexPipeline : uint64_t
	{
		FixedFunction = VG_VERTEX_PIPELINE_FIXED_FUNCTION,
		MeshShader    = VG_VERTEX_PIPELINE_MESH_SHADER,
	};

	enum class AttributeInputRate : uint64_t
	{
		Vertex   = VG_ATTRIBUTE_INPUT_RATE_VERTEX,
		Instance = VG_ATTRIBUTE_INPUT_RATE_INSTANCE,
	};

	enum class PrimitiveTopology : uint64_t
	{
		PointList                  = VG_PRIMITIVE_TOPOLOGY_POINT_LIST,
		LineList                   = VG_PRIMITIVE_TOPOLOGY_LINE_LIST,
		LineStrip                  = VG_PRIMITIVE_TOPOLOGY_LINE_STRIP,
		TriangleList               = VG_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
		TriangleStrip              = VG_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
		LineListWithAdjacency      = VG_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
		LineStripWithAdjacency     = VG_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
		TriangleListWithAdjacency  = VG_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY,
		TriangleStripWithAdjacency = VG_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY,
		PatchList                  = VG_PRIMITIVE_TOPOLOGY_PATCH_LIST,
	};

	enum class FillMode : uint64_t
	{
		Fill      = VG_FILL_MODE_FILL,
		Wireframe = VG_FILL_MODE_WIREFRAME,
	};

	enum class FrontFace : uint64_t
	{
		Clockwise        = VG_FRONT_FACE_CLOCKWISE,
		CounterClockwise = VG_FRONT_FACE_COUNTER_CLOCKWISE,
	};

	enum class CullMode : uint64_t
	{
		None  = VG_CULL_MODE_NONE,
		Front = VG_CULL_MODE_FRONT,
		Back  = VG_CULL_MODE_BACK,
	};

	enum class DepthClipMode : uint64_t
	{
		Clip  = VG_DEPTH_CLIP_MODE_CLIP,
		Clamp = VG_DEPTH_CLIP_MODE_CLAMP,
	};

	enum class CompareOp : uint64_t
	{
		Never          = VG_COMPARE_OP_NEVER,
		Less           = VG_COMPARE_OP_LESS,
		Equal          = VG_COMPARE_OP_EQUAL,
		LessOrEqual    = VG_COMPARE_OP_LESS_OR_EQUAL,
		Greater        = VG_COMPARE_OP_GREATER,
		NotEqual       = VG_COMPARE_OP_NOT_EQUAL,
		GreaterOrEqual = VG_COMPARE_OP_GREATER_OR_EQUAL,
		Always         = VG_COMPARE_OP_ALWAYS,
	};

	enum class StencilOp : uint64_t
	{
		Keep              = VG_STENCIL_OP_KEEP,
		Zero              = VG_STENCIL_OP_ZERO,
		Replace           = VG_STENCIL_OP_REPLACE,
		IncrementAndClamp = VG_STENCIL_OP_INCREMENT_AND_CLAMP,
		DecrementAndClamp = VG_STENCIL_OP_DECREMENT_AND_CLAMP,
		Invert            = VG_STENCIL_OP_INVERT,
		IncrementAndWrap  = VG_STENCIL_OP_INCREMENT_AND_WRAP,
		DecrementAndWrap  = VG_STENCIL_OP_DECREMENT_AND_WRAP,
	};

	enum class LogicOp : uint64_t
	{
		Clear        = VG_LOGIC_OP_CLEAR,
		And          = VG_LOGIC_OP_AND,
		AndReverse   = VG_LOGIC_OP_AND_REVERSE,
		Copy         = VG_LOGIC_OP_COPY,
		AndInverted  = VG_LOGIC_OP_AND_INVERTED,
		NoOp         = VG_LOGIC_OP_NO_OP,
		Xor          = VG_LOGIC_OP_XOR,
		Or           = VG_LOGIC_OP_OR,
		Nor          = VG_LOGIC_OP_NOR,
		Equivalent   = VG_LOGIC_OP_EQUIVALENT,
		Invert       = VG_LOGIC_OP_INVERT,
		OrReverse    = VG_LOGIC_OP_OR_REVERSE,
		CopyInverted = VG_LOGIC_OP_COPY_INVERTED,
		OrInverted   = VG_LOGIC_OP_OR_INVERTED,
		Nand         = VG_LOGIC_OP_NAND,
		Set          = VG_LOGIC_OP_SET,
	};

	enum class BlendFactor : uint64_t
	{
		Zero                  = VG_BLEND_FACTOR_ZERO,
		One                   = VG_BLEND_FACTOR_ONE,
		SrcColor              = VG_BLEND_FACTOR_SRC_COLOR,
		OneMinusSrcColor      = VG_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
		DstColor              = VG_BLEND_FACTOR_DST_COLOR,
		OneMinusDstColor      = VG_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
		SrcAlpha              = VG_BLEND_FACTOR_SRC_ALPHA,
		OneMinusSrcAlpha      = VG_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
		DstAlpha              = VG_BLEND_FACTOR_DST_ALPHA,
		OneMinusDstAlpha      = VG_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
		ConstantColor         = VG_BLEND_FACTOR_CONSTANT_COLOR,
		OneMinusConstantColor = VG_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
		ConstantAlpha         = VG_BLEND_FACTOR_CONSTANT_ALPHA,
		OneMinusConstantAlpha = VG_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
		SrcAlphaSaturate      = VG_BLEND_FACTOR_SRC_ALPHA_SATURATE,
		Src1Color             = VG_BLEND_FACTOR_SRC1_COLOR,
		OneMinusSrc1Color     = VG_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
		Src1Alpha             = VG_BLEND_FACTOR_SRC1_ALPHA,
		OneMinusSrc1Alpha     = VG_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
	};

	enum class BlendOp : uint64_t
	{
		Add             = VG_BLEND_OP_ADD,
		Subtract        = VG_BLEND_OP_SUBTRACT,
		ReverseSubtract = VG_BLEND_OP_REVERSE_SUBTRACT,
		Min             = VG_BLEND_OP_MIN,
		Max             = VG_BLEND_OP_MAX,
	};

	enum class ColorComponentFlags : uint64_t
	{
		R = VG_COLOR_COMPONENT_R,
		G = VG_COLOR_COMPONENT_G,
		B = VG_COLOR_COMPONENT_B,
		A = VG_COLOR_COMPONENT_A,
	};

	using AllocPFN = VgAllocPFN;
	using ReallocPFN = VgReallocPFN;
	using FreePFN = VgFreePFN;
	using MessageCallbackPFN = VgMessageCallbackPFN;

	struct Allocator;
	struct Config;
	struct AdapterProperties;
	struct BufferDesc;
	struct VertexBufferView;
	struct BufferViewDesc;
	struct FenceOperation;
	struct SubmitInfo;
	struct TextureSubresourceRange;
	struct MemoryBarrier;
	struct BufferBarrier;
	struct TextureBarrier;
	struct DependencyInfo;
	struct SamplerDesc;
	struct TextureDesc;
	struct AttachmentViewDesc;
	struct ClearValue;
	struct AttachmentInfo;
	struct RenderingInfo;
	struct ComponentSwizzle;
	struct TextureViewDesc;
	struct Offset;
	struct Region;
	struct SwapChainDesc;
	struct VertexAttribute;
	struct FixedFunctionState;
	struct MeshShaderState;
	struct RasterizationState;
	struct StencilState;
	struct DepthStencilState;
	struct MultisamplingState;
	struct AttachmentBlendState;
	struct BlendState;
	struct GraphicsPipelineDesc;
	struct Viewport;
	struct Scissor;
	struct MemoryStatistics;
	struct DrawIndirectCommand;
	struct DrawIndexedIndirectCommand;
	struct DispatchIndirectCommand;
	struct VulkanObjects;

	vg::Result Init                (const vg::Config* cfg);

	void       Shutdown            ();

	vg::Result EnumerateApis       (uint32_t* outNumApis,
	                                vg::GraphicsApi* outApis);

	vg::Result EnumerateAdapters   (vg::GraphicsApi api,
	                                vg::Surface surface,
	                                uint32_t* outNumAdapters,
	                                vg::Adapter* outAdapters);

	vg::Result GetVulkanObjects    (vg::VulkanObjects* outVulkanObjects);

	vg::Result CreateSurfaceD3D12  (void* hwnd,
	                                vg::Surface* outSurface);

	vg::Result CreateSurfaceVulkan (VkSurfaceKHR_T* vkSurface,
	                                vg::Surface* outSurface);

	void       DestroySurfaceVulkan(vg::Surface surface);

	class Adapter
	{
	public:
		using NativeType = VgAdapter;

		Adapter() : _handle{ nullptr } {}
		Adapter(std::nullptr_t) : _handle{ nullptr } {}
		Adapter(VgAdapter handle) : _handle{ handle } {}
		Adapter(const vg::Adapter&) = default;
		Adapter(vg::Adapter&&) = default;
		~Adapter() = default;

		constexpr Adapter& operator=(const vg::Adapter&) noexcept = default;
		inline Adapter& operator=(const VgAdapter& other) noexcept
		{
			*this = *reinterpret_cast<const vg::Adapter*>(&other);
			return *this;
		}
		constexpr operator VgAdapter&() noexcept { return _handle; }
		constexpr operator const VgAdapter&() const noexcept { return _handle; }
		constexpr operator bool() const noexcept { return _handle; }
		auto operator<=>(Adapter const&) const = default;

		vg::Result GetProperties(vg::AdapterProperties* outProperties) const;

		vg::Result CreateDevice (vg::Device* outDevice);

		void       DestroyDevice(vg::Device device);

	private:
		VgAdapter _handle;
	};

	class Device
	{
	public:
		using NativeType = VgDevice;

		Device() : _handle{ nullptr } {}
		Device(std::nullptr_t) : _handle{ nullptr } {}
		Device(VgDevice handle) : _handle{ handle } {}
		Device(const vg::Device&) = default;
		Device(vg::Device&&) = default;
		~Device() = default;

		constexpr Device& operator=(const vg::Device&) noexcept = default;
		inline Device& operator=(const VgDevice& other) noexcept
		{
			*this = *reinterpret_cast<const vg::Device*>(&other);
			return *this;
		}
		constexpr operator VgDevice&() noexcept { return _handle; }
		constexpr operator const VgDevice&() const noexcept { return _handle; }
		constexpr operator bool() const noexcept { return _handle; }
		auto operator<=>(Device const&) const = default;

		vg::Result GetApiObject          (void** outObj) const;

		vg::Result GetAdapter            (vg::Adapter* outAdapter) const;

		vg::Result GetGraphicsApi        (vg::GraphicsApi* outApi) const;

		vg::Result GetMemoryStatistics   (vg::MemoryStatistics* outMemoryStats) const;

		void       WaitQueueIdle         (vg::Queue queue);

		void       WaitIdle              ();

		vg::Result CreateBuffer          (const vg::BufferDesc* desc,
		                                  vg::Buffer* outBuffer);

		void       DestroyBuffer         (vg::Buffer buffer);

		vg::Result CreateShaderModule    (const void* data,
		                                  uint64_t size,
		                                  vg::ShaderModule* outModule);

		void       DestroyShaderModule   (vg::ShaderModule shaderModule);

		vg::Result CreateGraphicsPipeline(const vg::GraphicsPipelineDesc* desc,
		                                  vg::Pipeline* outPipeline);

		vg::Result CreateComputePipeline (vg::ShaderModule shaderModule,
		                                  vg::Pipeline* outPipeline);

		void       DestroyPipeline       (vg::Pipeline pipeline);

		vg::Result CreateFence           (uint64_t initialValue,
		                                  vg::Fence* outFence);

		void       DestroyFence          (vg::Fence fence);

		vg::Result CreateCommandPool     (vg::CommandPoolFlags flags,
		                                  vg::Queue queue,
		                                  vg::CommandPool* outPool);

		void       DestroyCommandPool    (vg::CommandPool pool);

		vg::Result CreateSampler         (const vg::SamplerDesc* desc,
		                                  vg::Sampler* outSampler);

		void       DestroySampler        (vg::Sampler sampler);

		vg::Result CreateTexture         (const vg::TextureDesc* desc,
		                                  vg::Texture* outTexture);

		void       DestroyTexture        (vg::Texture texture);

		void       SubmitCommandLists    (uint32_t numSubmits,
		                                  vg::SubmitInfo* submits);

		vg::Result SignalFence           (vg::Fence fence,
		                                  uint64_t value);

		void       WaitFence             (vg::Fence fence,
		                                  uint64_t value);

		vg::Result GetFenceValue         (vg::Fence fence,
		                                  uint64_t* outValue) const;

		vg::Result CreateSwapChain       (const vg::SwapChainDesc* desc,
		                                  vg::SwapChain* outSwapChain);

		void       DestroySwapChain      (vg::SwapChain swapChain);

		vg::Result GetSamplerIndex       (vg::Sampler sampler,
		                                  uint32_t* outIndex) const;

	private:
		VgDevice _handle;
	};

	class CommandPool
	{
	public:
		using NativeType = VgCommandPool;

		CommandPool() : _handle{ nullptr } {}
		CommandPool(std::nullptr_t) : _handle{ nullptr } {}
		CommandPool(VgCommandPool handle) : _handle{ handle } {}
		CommandPool(const vg::CommandPool&) = default;
		CommandPool(vg::CommandPool&&) = default;
		~CommandPool() = default;

		constexpr CommandPool& operator=(const vg::CommandPool&) noexcept = default;
		inline CommandPool& operator=(const VgCommandPool& other) noexcept
		{
			*this = *reinterpret_cast<const vg::CommandPool*>(&other);
			return *this;
		}
		constexpr operator VgCommandPool&() noexcept { return _handle; }
		constexpr operator const VgCommandPool&() const noexcept { return _handle; }
		constexpr operator bool() const noexcept { return _handle; }
		auto operator<=>(CommandPool const&) const = default;

		vg::Result GetApiObject       (void** outObj) const;

		void       SetName            (const char* name);

		vg::Result GetDevice          (vg::Device* outDevice) const;

		vg::Result GetQueue           (vg::Queue* outQueue) const;

		vg::Result AllocateCommandList(vg::CommandList* outCmd);

		void       FreeCommandList    (vg::CommandList cmd);

		void       Reset              ();

	private:
		VgCommandPool _handle;
	};

	class CommandList
	{
	public:
		using NativeType = VgCommandList;

		CommandList() : _handle{ nullptr } {}
		CommandList(std::nullptr_t) : _handle{ nullptr } {}
		CommandList(VgCommandList handle) : _handle{ handle } {}
		CommandList(const vg::CommandList&) = default;
		CommandList(vg::CommandList&&) = default;
		~CommandList() = default;

		constexpr CommandList& operator=(const vg::CommandList&) noexcept = default;
		inline CommandList& operator=(const VgCommandList& other) noexcept
		{
			*this = *reinterpret_cast<const vg::CommandList*>(&other);
			return *this;
		}
		constexpr operator VgCommandList&() noexcept { return _handle; }
		constexpr operator const VgCommandList&() const noexcept { return _handle; }
		constexpr operator bool() const noexcept { return _handle; }
		auto operator<=>(CommandList const&) const = default;

		vg::Result GetApiObject            (void** outObj) const;

		void       SetName                 (const char* name);

		vg::Result GetDevice               (vg::Device* outDevice) const;

		vg::Result GetCommandPool          (vg::CommandPool* outPool) const;

		vg::Result GetQueue                (vg::Queue* outQueue) const;

		void       RestoreDescriptorState  ();

		void       Begin                   ();

		void       End                     ();

		void       SetVertexBuffers        (uint32_t startSlot,
		                                    uint32_t numBuffers,
		                                    const vg::VertexBufferView* buffers);

		void       SetIndexBuffer          (vg::IndexType indexType,
		                                    uint64_t offset,
		                                    vg::Buffer indexBuffer);

		void       SetRootConstants        (vg::PipelineType pipelineType,
		                                    uint32_t offsetIn32bitValues,
		                                    uint32_t num32bitValues,
		                                    const void* data);

		void       SetPipeline             (vg::Pipeline pipeline);

		void       Barrier                 (const vg::DependencyInfo* dependencyInfo);

		vg::Result BeginRendering          (const vg::RenderingInfo* info);

		void       EndRendering            ();

		void       SetViewport             (uint32_t firstViewport,
		                                    uint32_t numViewports,
		                                    vg::Viewport* viewports);

		void       SetScissor              (uint32_t firstScissor,
		                                    uint32_t numScissors,
		                                    vg::Scissor* scissors);

		void       Draw                    (uint32_t vertexCount,
		                                    uint32_t instanceCount,
		                                    uint32_t firstVertex,
		                                    uint32_t firstInstance);

		void       DrawIndexed             (uint32_t indexCount,
		                                    uint32_t instanceCount,
		                                    uint32_t firstIndex,
		                                    uint32_t vertexOffset,
		                                    uint32_t firstInstance);

		void       Dispatch                (uint32_t groupsX,
		                                    uint32_t groupsY,
		                                    uint32_t groupsZ);

		void       DrawIndirect            (vg::Buffer buffer,
		                                    uint64_t offset,
		                                    uint32_t drawCount,
		                                    uint32_t stride);

		void       DrawIndirectCount       (vg::Buffer buffer,
		                                    uint64_t offset,
		                                    vg::Buffer countBuffer,
		                                    uint64_t countBufferOffset,
		                                    uint32_t maxDrawCount,
		                                    uint32_t stride);

		void       DrawIndexedIndirect     (vg::Buffer buffer,
		                                    uint64_t offset,
		                                    uint32_t drawCount,
		                                    uint32_t stride);

		void       DrawIndexedIndirectCount(vg::Buffer buffer,
		                                    uint64_t offset,
		                                    vg::Buffer countBuffer,
		                                    uint64_t countBufferOffset,
		                                    uint32_t maxDrawCount,
		                                    uint32_t stride);

		void       DispatchIndirect        (vg::Buffer buffer,
		                                    uint64_t offset);

		void       CopyBufferToBuffer      (vg::Buffer dst,
		                                    uint64_t dstOffset,
		                                    vg::Buffer src,
		                                    uint64_t srcOffset,
		                                    uint64_t size);

		void       CopyBufferToTexture     (vg::Texture dst,
		                                    const vg::Region* dstRegion,
		                                    vg::Buffer src,
		                                    uint64_t srcOffset);

		void       CopyTextureToBuffer     (vg::Buffer dst,
		                                    uint64_t dstOffset,
		                                    vg::Texture src,
		                                    const vg::Region* srcRegion);

		void       CopyTextureToTexture    (vg::Texture dst,
		                                    const vg::Region* dstRegion,
		                                    vg::Texture src,
		                                    const vg::Region* srcRegion);

		void       BeginMarker             (const char* name,
		                                    std::array<float, 3> color);

		void       EndMarker               ();

	private:
		VgCommandList _handle;
	};

	class Buffer
	{
	public:
		using NativeType = VgBuffer;

		Buffer() : _handle{ nullptr } {}
		Buffer(std::nullptr_t) : _handle{ nullptr } {}
		Buffer(VgBuffer handle) : _handle{ handle } {}
		Buffer(const vg::Buffer&) = default;
		Buffer(vg::Buffer&&) = default;
		~Buffer() = default;

		constexpr Buffer& operator=(const vg::Buffer&) noexcept = default;
		inline Buffer& operator=(const VgBuffer& other) noexcept
		{
			*this = *reinterpret_cast<const vg::Buffer*>(&other);
			return *this;
		}
		constexpr operator VgBuffer&() noexcept { return _handle; }
		constexpr operator const VgBuffer&() const noexcept { return _handle; }
		constexpr operator bool() const noexcept { return _handle; }
		auto operator<=>(Buffer const&) const = default;

		vg::Result GetApiObject(void** outObj) const;

		void       SetName     (const char* name);

		vg::Result GetDevice   (vg::Device* outDevice) const;

		vg::Result GetDesc     (vg::BufferDesc* outDesc) const;

		vg::Result CreateView  (const vg::BufferViewDesc* desc,
		                        vg::View* outDescriptor);

		void       DestroyViews();

		vg::Result Map         (void** outData);

		void       Unmap       ();

	private:
		VgBuffer _handle;
	};

	class Pipeline
	{
	public:
		using NativeType = VgPipeline;

		Pipeline() : _handle{ nullptr } {}
		Pipeline(std::nullptr_t) : _handle{ nullptr } {}
		Pipeline(VgPipeline handle) : _handle{ handle } {}
		Pipeline(const vg::Pipeline&) = default;
		Pipeline(vg::Pipeline&&) = default;
		~Pipeline() = default;

		constexpr Pipeline& operator=(const vg::Pipeline&) noexcept = default;
		inline Pipeline& operator=(const VgPipeline& other) noexcept
		{
			*this = *reinterpret_cast<const vg::Pipeline*>(&other);
			return *this;
		}
		constexpr operator VgPipeline&() noexcept { return _handle; }
		constexpr operator const VgPipeline&() const noexcept { return _handle; }
		constexpr operator bool() const noexcept { return _handle; }
		auto operator<=>(Pipeline const&) const = default;

		vg::Result GetApiObject(void** outObj) const;

		void       SetName     (const char* name);

		vg::Result GetDevice   (vg::Device* outDevice) const;

		vg::Result GetType     (vg::PipelineType* outType) const;

	private:
		VgPipeline _handle;
	};

	class Texture
	{
	public:
		using NativeType = VgTexture;

		Texture() : _handle{ nullptr } {}
		Texture(std::nullptr_t) : _handle{ nullptr } {}
		Texture(VgTexture handle) : _handle{ handle } {}
		Texture(const vg::Texture&) = default;
		Texture(vg::Texture&&) = default;
		~Texture() = default;

		constexpr Texture& operator=(const vg::Texture&) noexcept = default;
		inline Texture& operator=(const VgTexture& other) noexcept
		{
			*this = *reinterpret_cast<const vg::Texture*>(&other);
			return *this;
		}
		constexpr operator VgTexture&() noexcept { return _handle; }
		constexpr operator const VgTexture&() const noexcept { return _handle; }
		constexpr operator bool() const noexcept { return _handle; }
		auto operator<=>(Texture const&) const = default;

		vg::Result GetApiObject        (void** outObj) const;

		void       SetName             (const char* name);

		vg::Result GetDevice           (vg::Device* outDevice) const;

		vg::Result GetDesc             (vg::TextureDesc* outDesc) const;

		vg::Result CreateAttachmentView(const vg::AttachmentViewDesc* desc,
		                                vg::AttachmentView* outDescriptor);

		vg::Result CreateView          (const vg::TextureViewDesc* desc,
		                                vg::View* outDescriptor);

		void       DestroyViews        ();

	private:
		VgTexture _handle;
	};

	class SwapChain
	{
	public:
		using NativeType = VgSwapChain;

		SwapChain() : _handle{ nullptr } {}
		SwapChain(std::nullptr_t) : _handle{ nullptr } {}
		SwapChain(VgSwapChain handle) : _handle{ handle } {}
		SwapChain(const vg::SwapChain&) = default;
		SwapChain(vg::SwapChain&&) = default;
		~SwapChain() = default;

		constexpr SwapChain& operator=(const vg::SwapChain&) noexcept = default;
		inline SwapChain& operator=(const VgSwapChain& other) noexcept
		{
			*this = *reinterpret_cast<const vg::SwapChain*>(&other);
			return *this;
		}
		constexpr operator VgSwapChain&() noexcept { return _handle; }
		constexpr operator const VgSwapChain&() const noexcept { return _handle; }
		constexpr operator bool() const noexcept { return _handle; }
		auto operator<=>(SwapChain const&) const = default;

		vg::Result GetApiObject    (void** outObj) const;

		vg::Result GetDevice       (vg::Device* outDevice) const;

		vg::Result GetDesc         (vg::SwapChainDesc* outDesc) const;

		vg::Result AcquireNextImage(uint32_t* outImageIndex);

		vg::Result GetBackBuffer   (uint32_t index,
		                            vg::Texture* outBackBuffer) const;

		vg::Result Present         (uint32_t numWaitFences,
		                            vg::FenceOperation* waitFences);

	private:
		VgSwapChain _handle;
	};


	struct ClearColor
	{
		float color[4];
	
		ClearColor(float r, float g, float b, float a)
		{
		    color[0] = r;
		    color[1] = g;
		    color[2] = b;
		    color[3] = a;
		}
	};
	
	struct ClearDepth
	{
		float depth;
	
		explicit ClearDepth(float depth) : depth(depth) {}
	};
	
	struct ClearStencil
	{
		uint32_t stencil;
	
		explicit ClearStencil(uint32_t stencil) : stencil(stencil) {}
	
	};
	
	struct ClearValue
	{
		using NativeType = VgClearValue;
		VgClearValue clear;
	
		ClearValue() = default;
		ClearValue(const VgClearValue& clear_) : clear(clear_) {}
		ClearValue(const ClearColor& color)
		{
			memcpy(clear.color, color.color, sizeof(float) * 4);
		}
		ClearValue(ClearDepth depth)
		{
			clear.depth = depth.depth;
		}
		ClearValue(ClearStencil stencil)
		{
			clear.stencil = stencil.stencil;
		}
	};

	struct Allocator
	{
		using NativeType = VgAllocator;

		void* userData;
		AllocPFN alloc;
		ReallocPFN realloc;
		FreePFN free;

		Allocator() = default;

		Allocator(
			void*      userData_,
			AllocPFN   alloc_= {},
			ReallocPFN realloc_= {},
			FreePFN    free_= {})
		  : userData{ userData_ }
		  , alloc{ alloc_ }
		  , realloc{ realloc_ }
		  , free{ free_ } {}
		Allocator(const Allocator& other) = default;
		Allocator(const VgAllocator& other)
		  : Allocator(*reinterpret_cast<Allocator const*>(&other))
		{
		}

		constexpr Allocator& operator=(vg::Allocator const& other) noexcept = default;
		inline Allocator& operator=(VgAllocator const& other) noexcept
		{
			*this = *reinterpret_cast<vg::Allocator const*>(&other);
			return *this;
		}

		operator VgAllocator&() noexcept
		{
			return *reinterpret_cast<VgAllocator*>(this);
		}
		operator const VgAllocator&() const noexcept
		{
			return *reinterpret_cast<VgAllocator const*>(this);
		}

		auto operator<=>(Allocator const& other) const = default;
	};

	struct Config
	{
		using NativeType = VgConfig;

		const char* applicationName;
		const char* engineName;
		InitFlags flags;
		MessageCallbackPFN messageCallback;
		Allocator allocator;

		Config() = default;

		Config(
			const char*        applicationName_,
			const char*        engineName_= {},
			InitFlags          flags_= {},
			MessageCallbackPFN messageCallback_= {},
			Allocator          allocator_= {})
		  : applicationName{ applicationName_ }
		  , engineName{ engineName_ }
		  , flags{ flags_ }
		  , messageCallback{ messageCallback_ }
		  , allocator{ allocator_ } {}
		Config(const Config& other) = default;
		Config(const VgConfig& other)
		  : Config(*reinterpret_cast<Config const*>(&other))
		{
		}

		constexpr Config& operator=(vg::Config const& other) noexcept = default;
		inline Config& operator=(VgConfig const& other) noexcept
		{
			*this = *reinterpret_cast<vg::Config const*>(&other);
			return *this;
		}

		operator VgConfig&() noexcept
		{
			return *reinterpret_cast<VgConfig*>(this);
		}
		operator const VgConfig&() const noexcept
		{
			return *reinterpret_cast<VgConfig const*>(this);
		}

		auto operator<=>(Config const& other) const = default;
	};

	struct AdapterProperties
	{
		using NativeType = VgAdapterProperties;

		AdapterType type;
		char name[256u];
		uint64_t dedicatedVram;
		uint64_t dedicatedRam;
		uint64_t sharedRam;
		bool meshShaders;
		bool hardwareRayTracing;

		AdapterProperties() = default;

		AdapterProperties(
			AdapterType type_,
			char        name_= {},
			uint64_t    dedicatedVram_= {},
			uint64_t    dedicatedRam_= {},
			uint64_t    sharedRam_= {},
			bool        meshShaders_= {},
			bool        hardwareRayTracing_= {})
		  : type{ type_ }
		  , name{ name_ }
		  , dedicatedVram{ dedicatedVram_ }
		  , dedicatedRam{ dedicatedRam_ }
		  , sharedRam{ sharedRam_ }
		  , meshShaders{ meshShaders_ }
		  , hardwareRayTracing{ hardwareRayTracing_ } {}
		AdapterProperties(const AdapterProperties& other) = default;
		AdapterProperties(const VgAdapterProperties& other)
		  : AdapterProperties(*reinterpret_cast<AdapterProperties const*>(&other))
		{
		}

		constexpr AdapterProperties& operator=(vg::AdapterProperties const& other) noexcept = default;
		inline AdapterProperties& operator=(VgAdapterProperties const& other) noexcept
		{
			*this = *reinterpret_cast<vg::AdapterProperties const*>(&other);
			return *this;
		}

		operator VgAdapterProperties&() noexcept
		{
			return *reinterpret_cast<VgAdapterProperties*>(this);
		}
		operator const VgAdapterProperties&() const noexcept
		{
			return *reinterpret_cast<VgAdapterProperties const*>(this);
		}

		auto operator<=>(AdapterProperties const& other) const = default;
	};

	struct BufferDesc
	{
		using NativeType = VgBufferDesc;

		uint64_t size;
		BufferUsage usage;
		HeapType heapType;

		BufferDesc() = default;

		BufferDesc(
			uint64_t    size_,
			BufferUsage usage_= {},
			HeapType    heapType_= {})
		  : size{ size_ }
		  , usage{ usage_ }
		  , heapType{ heapType_ } {}
		BufferDesc(const BufferDesc& other) = default;
		BufferDesc(const VgBufferDesc& other)
		  : BufferDesc(*reinterpret_cast<BufferDesc const*>(&other))
		{
		}

		constexpr BufferDesc& operator=(vg::BufferDesc const& other) noexcept = default;
		inline BufferDesc& operator=(VgBufferDesc const& other) noexcept
		{
			*this = *reinterpret_cast<vg::BufferDesc const*>(&other);
			return *this;
		}

		operator VgBufferDesc&() noexcept
		{
			return *reinterpret_cast<VgBufferDesc*>(this);
		}
		operator const VgBufferDesc&() const noexcept
		{
			return *reinterpret_cast<VgBufferDesc const*>(this);
		}

		auto operator<=>(BufferDesc const& other) const = default;
	};

	struct VertexBufferView
	{
		using NativeType = VgVertexBufferView;

		Buffer buffer;
		uint64_t offset;
		uint32_t strideInBytes;

		VertexBufferView() = default;

		VertexBufferView(
			Buffer   buffer_,
			uint64_t offset_= {},
			uint32_t strideInBytes_= {})
		  : buffer{ buffer_ }
		  , offset{ offset_ }
		  , strideInBytes{ strideInBytes_ } {}
		VertexBufferView(const VertexBufferView& other) = default;
		VertexBufferView(const VgVertexBufferView& other)
		  : VertexBufferView(*reinterpret_cast<VertexBufferView const*>(&other))
		{
		}

		constexpr VertexBufferView& operator=(vg::VertexBufferView const& other) noexcept = default;
		inline VertexBufferView& operator=(VgVertexBufferView const& other) noexcept
		{
			*this = *reinterpret_cast<vg::VertexBufferView const*>(&other);
			return *this;
		}

		operator VgVertexBufferView&() noexcept
		{
			return *reinterpret_cast<VgVertexBufferView*>(this);
		}
		operator const VgVertexBufferView&() const noexcept
		{
			return *reinterpret_cast<VgVertexBufferView const*>(this);
		}

		auto operator<=>(VertexBufferView const& other) const = default;
	};

	struct BufferViewDesc
	{
		using NativeType = VgBufferViewDesc;

		BufferDescriptorType descriptorType;
		BufferViewType viewType;
		Format format;
		uint64_t offset;
		uint64_t size;
		uint64_t elementSize;

		BufferViewDesc() = default;

		BufferViewDesc(
			BufferDescriptorType descriptorType_,
			BufferViewType       viewType_= {},
			Format               format_= {},
			uint64_t             offset_= {},
			uint64_t             size_= {},
			uint64_t             elementSize_= {})
		  : descriptorType{ descriptorType_ }
		  , viewType{ viewType_ }
		  , format{ format_ }
		  , offset{ offset_ }
		  , size{ size_ }
		  , elementSize{ elementSize_ } {}
		BufferViewDesc(const BufferViewDesc& other) = default;
		BufferViewDesc(const VgBufferViewDesc& other)
		  : BufferViewDesc(*reinterpret_cast<BufferViewDesc const*>(&other))
		{
		}

		constexpr BufferViewDesc& operator=(vg::BufferViewDesc const& other) noexcept = default;
		inline BufferViewDesc& operator=(VgBufferViewDesc const& other) noexcept
		{
			*this = *reinterpret_cast<vg::BufferViewDesc const*>(&other);
			return *this;
		}

		operator VgBufferViewDesc&() noexcept
		{
			return *reinterpret_cast<VgBufferViewDesc*>(this);
		}
		operator const VgBufferViewDesc&() const noexcept
		{
			return *reinterpret_cast<VgBufferViewDesc const*>(this);
		}

		auto operator<=>(BufferViewDesc const& other) const = default;
	};

	struct FenceOperation
	{
		using NativeType = VgFenceOperation;

		Fence fence;
		uint64_t value;

		FenceOperation() = default;

		FenceOperation(
			Fence    fence_,
			uint64_t value_= {})
		  : fence{ fence_ }
		  , value{ value_ } {}
		FenceOperation(const FenceOperation& other) = default;
		FenceOperation(const VgFenceOperation& other)
		  : FenceOperation(*reinterpret_cast<FenceOperation const*>(&other))
		{
		}

		constexpr FenceOperation& operator=(vg::FenceOperation const& other) noexcept = default;
		inline FenceOperation& operator=(VgFenceOperation const& other) noexcept
		{
			*this = *reinterpret_cast<vg::FenceOperation const*>(&other);
			return *this;
		}

		operator VgFenceOperation&() noexcept
		{
			return *reinterpret_cast<VgFenceOperation*>(this);
		}
		operator const VgFenceOperation&() const noexcept
		{
			return *reinterpret_cast<VgFenceOperation const*>(this);
		}

		auto operator<=>(FenceOperation const& other) const = default;
	};

	struct SubmitInfo
	{
		using NativeType = VgSubmitInfo;

		uint32_t numWaitFences;
		FenceOperation* waitFences;
		uint32_t numSignalFences;
		FenceOperation* signalFences;
		uint32_t numCommandLists;
		CommandList* commandLists;

		SubmitInfo() = default;

		SubmitInfo(
			uint32_t        numWaitFences_,
			FenceOperation* waitFences_= {},
			uint32_t        numSignalFences_= {},
			FenceOperation* signalFences_= {},
			uint32_t        numCommandLists_= {},
			CommandList*    commandLists_= {})
		  : numWaitFences{ numWaitFences_ }
		  , waitFences{ waitFences_ }
		  , numSignalFences{ numSignalFences_ }
		  , signalFences{ signalFences_ }
		  , numCommandLists{ numCommandLists_ }
		  , commandLists{ commandLists_ } {}
		SubmitInfo(const SubmitInfo& other) = default;
		SubmitInfo(const VgSubmitInfo& other)
		  : SubmitInfo(*reinterpret_cast<SubmitInfo const*>(&other))
		{
		}

		constexpr SubmitInfo& operator=(vg::SubmitInfo const& other) noexcept = default;
		inline SubmitInfo& operator=(VgSubmitInfo const& other) noexcept
		{
			*this = *reinterpret_cast<vg::SubmitInfo const*>(&other);
			return *this;
		}

		operator VgSubmitInfo&() noexcept
		{
			return *reinterpret_cast<VgSubmitInfo*>(this);
		}
		operator const VgSubmitInfo&() const noexcept
		{
			return *reinterpret_cast<VgSubmitInfo const*>(this);
		}

		auto operator<=>(SubmitInfo const& other) const = default;
	};

	struct TextureSubresourceRange
	{
		using NativeType = VgTextureSubresourceRange;

		uint32_t baseMipLevel;
		uint32_t mipLevels;
		uint32_t baseArrayLayer;
		uint32_t arrayLayers;

		TextureSubresourceRange() = default;

		TextureSubresourceRange(
			uint32_t baseMipLevel_,
			uint32_t mipLevels_= {},
			uint32_t baseArrayLayer_= {},
			uint32_t arrayLayers_= {})
		  : baseMipLevel{ baseMipLevel_ }
		  , mipLevels{ mipLevels_ }
		  , baseArrayLayer{ baseArrayLayer_ }
		  , arrayLayers{ arrayLayers_ } {}
		TextureSubresourceRange(const TextureSubresourceRange& other) = default;
		TextureSubresourceRange(const VgTextureSubresourceRange& other)
		  : TextureSubresourceRange(*reinterpret_cast<TextureSubresourceRange const*>(&other))
		{
		}

		constexpr TextureSubresourceRange& operator=(vg::TextureSubresourceRange const& other) noexcept = default;
		inline TextureSubresourceRange& operator=(VgTextureSubresourceRange const& other) noexcept
		{
			*this = *reinterpret_cast<vg::TextureSubresourceRange const*>(&other);
			return *this;
		}

		operator VgTextureSubresourceRange&() noexcept
		{
			return *reinterpret_cast<VgTextureSubresourceRange*>(this);
		}
		operator const VgTextureSubresourceRange&() const noexcept
		{
			return *reinterpret_cast<VgTextureSubresourceRange const*>(this);
		}

		auto operator<=>(TextureSubresourceRange const& other) const = default;
	};

	struct MemoryBarrier
	{
		using NativeType = VgMemoryBarrier;

		PipelineStageFlags srcStage;
		AccessFlags srcAccess;
		PipelineStageFlags dstStage;
		AccessFlags dstAccess;

		MemoryBarrier() = default;

		MemoryBarrier(
			PipelineStageFlags srcStage_,
			AccessFlags        srcAccess_= {},
			PipelineStageFlags dstStage_= {},
			AccessFlags        dstAccess_= {})
		  : srcStage{ srcStage_ }
		  , srcAccess{ srcAccess_ }
		  , dstStage{ dstStage_ }
		  , dstAccess{ dstAccess_ } {}
		MemoryBarrier(const MemoryBarrier& other) = default;
		MemoryBarrier(const VgMemoryBarrier& other)
		  : MemoryBarrier(*reinterpret_cast<MemoryBarrier const*>(&other))
		{
		}

		constexpr MemoryBarrier& operator=(vg::MemoryBarrier const& other) noexcept = default;
		inline MemoryBarrier& operator=(VgMemoryBarrier const& other) noexcept
		{
			*this = *reinterpret_cast<vg::MemoryBarrier const*>(&other);
			return *this;
		}

		operator VgMemoryBarrier&() noexcept
		{
			return *reinterpret_cast<VgMemoryBarrier*>(this);
		}
		operator const VgMemoryBarrier&() const noexcept
		{
			return *reinterpret_cast<VgMemoryBarrier const*>(this);
		}

		auto operator<=>(MemoryBarrier const& other) const = default;
	};

	struct BufferBarrier
	{
		using NativeType = VgBufferBarrier;

		PipelineStageFlags srcStage;
		AccessFlags srcAccess;
		PipelineStageFlags dstStage;
		AccessFlags dstAccess;
		Buffer buffer;

		BufferBarrier() = default;

		BufferBarrier(
			PipelineStageFlags srcStage_,
			AccessFlags        srcAccess_= {},
			PipelineStageFlags dstStage_= {},
			AccessFlags        dstAccess_= {},
			Buffer             buffer_= {})
		  : srcStage{ srcStage_ }
		  , srcAccess{ srcAccess_ }
		  , dstStage{ dstStage_ }
		  , dstAccess{ dstAccess_ }
		  , buffer{ buffer_ } {}
		BufferBarrier(const BufferBarrier& other) = default;
		BufferBarrier(const VgBufferBarrier& other)
		  : BufferBarrier(*reinterpret_cast<BufferBarrier const*>(&other))
		{
		}

		constexpr BufferBarrier& operator=(vg::BufferBarrier const& other) noexcept = default;
		inline BufferBarrier& operator=(VgBufferBarrier const& other) noexcept
		{
			*this = *reinterpret_cast<vg::BufferBarrier const*>(&other);
			return *this;
		}

		operator VgBufferBarrier&() noexcept
		{
			return *reinterpret_cast<VgBufferBarrier*>(this);
		}
		operator const VgBufferBarrier&() const noexcept
		{
			return *reinterpret_cast<VgBufferBarrier const*>(this);
		}

		auto operator<=>(BufferBarrier const& other) const = default;
	};

	struct TextureBarrier
	{
		using NativeType = VgTextureBarrier;

		PipelineStageFlags srcStage;
		AccessFlags srcAccess;
		PipelineStageFlags dstStage;
		AccessFlags dstAccess;
		TextureLayout oldLayout;
		TextureLayout newLayout;
		Texture texture;
		TextureSubresourceRange subresourceRange;

		TextureBarrier() = default;

		TextureBarrier(
			PipelineStageFlags      srcStage_,
			AccessFlags             srcAccess_= {},
			PipelineStageFlags      dstStage_= {},
			AccessFlags             dstAccess_= {},
			TextureLayout           oldLayout_= {},
			TextureLayout           newLayout_= {},
			Texture                 texture_= {},
			TextureSubresourceRange subresourceRange_= {})
		  : srcStage{ srcStage_ }
		  , srcAccess{ srcAccess_ }
		  , dstStage{ dstStage_ }
		  , dstAccess{ dstAccess_ }
		  , oldLayout{ oldLayout_ }
		  , newLayout{ newLayout_ }
		  , texture{ texture_ }
		  , subresourceRange{ subresourceRange_ } {}
		TextureBarrier(const TextureBarrier& other) = default;
		TextureBarrier(const VgTextureBarrier& other)
		  : TextureBarrier(*reinterpret_cast<TextureBarrier const*>(&other))
		{
		}

		constexpr TextureBarrier& operator=(vg::TextureBarrier const& other) noexcept = default;
		inline TextureBarrier& operator=(VgTextureBarrier const& other) noexcept
		{
			*this = *reinterpret_cast<vg::TextureBarrier const*>(&other);
			return *this;
		}

		operator VgTextureBarrier&() noexcept
		{
			return *reinterpret_cast<VgTextureBarrier*>(this);
		}
		operator const VgTextureBarrier&() const noexcept
		{
			return *reinterpret_cast<VgTextureBarrier const*>(this);
		}

		auto operator<=>(TextureBarrier const& other) const = default;
	};

	struct DependencyInfo
	{
		using NativeType = VgDependencyInfo;

		uint32_t numMemoryBarriers;
		MemoryBarrier* memoryBarriers;
		uint32_t numBufferBarriers;
		BufferBarrier* bufferBarriers;
		uint32_t numTextureBarriers;
		TextureBarrier* textureBarriers;

		DependencyInfo() = default;

		DependencyInfo(
			uint32_t        numMemoryBarriers_,
			MemoryBarrier*  memoryBarriers_= {},
			uint32_t        numBufferBarriers_= {},
			BufferBarrier*  bufferBarriers_= {},
			uint32_t        numTextureBarriers_= {},
			TextureBarrier* textureBarriers_= {})
		  : numMemoryBarriers{ numMemoryBarriers_ }
		  , memoryBarriers{ memoryBarriers_ }
		  , numBufferBarriers{ numBufferBarriers_ }
		  , bufferBarriers{ bufferBarriers_ }
		  , numTextureBarriers{ numTextureBarriers_ }
		  , textureBarriers{ textureBarriers_ } {}
		DependencyInfo(const DependencyInfo& other) = default;
		DependencyInfo(const VgDependencyInfo& other)
		  : DependencyInfo(*reinterpret_cast<DependencyInfo const*>(&other))
		{
		}

		constexpr DependencyInfo& operator=(vg::DependencyInfo const& other) noexcept = default;
		inline DependencyInfo& operator=(VgDependencyInfo const& other) noexcept
		{
			*this = *reinterpret_cast<vg::DependencyInfo const*>(&other);
			return *this;
		}

		operator VgDependencyInfo&() noexcept
		{
			return *reinterpret_cast<VgDependencyInfo*>(this);
		}
		operator const VgDependencyInfo&() const noexcept
		{
			return *reinterpret_cast<VgDependencyInfo const*>(this);
		}

		auto operator<=>(DependencyInfo const& other) const = default;
	};

	struct SamplerDesc
	{
		using NativeType = VgSamplerDesc;

		Filter magFilter;
		Filter minFilter;
		MipmapMode mipmapMode;
		AddressMode addressU;
		AddressMode addressV;
		AddressMode addressW;
		float mipLodBias;
		Anisotropy maxAnisotropy;
		ComparisonFunc comparisonFunc;
		float borderColor[4];
		float minLod;
		float maxLod;
		ReductionMode reductionMode;

		SamplerDesc() = default;

		SamplerDesc(
			Filter         magFilter_,
			Filter         minFilter_= {},
			MipmapMode     mipmapMode_= {},
			AddressMode    addressU_= {},
			AddressMode    addressV_= {},
			AddressMode    addressW_= {},
			float          mipLodBias_= {},
			Anisotropy     maxAnisotropy_= {},
			ComparisonFunc comparisonFunc_= {},
			float          borderColor_= {},
			float          minLod_= {},
			float          maxLod_= {},
			ReductionMode  reductionMode_= {})
		  : magFilter{ magFilter_ }
		  , minFilter{ minFilter_ }
		  , mipmapMode{ mipmapMode_ }
		  , addressU{ addressU_ }
		  , addressV{ addressV_ }
		  , addressW{ addressW_ }
		  , mipLodBias{ mipLodBias_ }
		  , maxAnisotropy{ maxAnisotropy_ }
		  , comparisonFunc{ comparisonFunc_ }
		  , borderColor{ borderColor_ }
		  , minLod{ minLod_ }
		  , maxLod{ maxLod_ }
		  , reductionMode{ reductionMode_ } {}
		SamplerDesc(const SamplerDesc& other) = default;
		SamplerDesc(const VgSamplerDesc& other)
		  : SamplerDesc(*reinterpret_cast<SamplerDesc const*>(&other))
		{
		}

		constexpr SamplerDesc& operator=(vg::SamplerDesc const& other) noexcept = default;
		inline SamplerDesc& operator=(VgSamplerDesc const& other) noexcept
		{
			*this = *reinterpret_cast<vg::SamplerDesc const*>(&other);
			return *this;
		}

		operator VgSamplerDesc&() noexcept
		{
			return *reinterpret_cast<VgSamplerDesc*>(this);
		}
		operator const VgSamplerDesc&() const noexcept
		{
			return *reinterpret_cast<VgSamplerDesc const*>(this);
		}

		auto operator<=>(SamplerDesc const& other) const = default;
	};

	struct TextureDesc
	{
		using NativeType = VgTextureDesc;

		TextureType type;
		Format format;
		uint32_t width;
		uint32_t height;
		uint32_t depthOrArrayLayers;
		uint32_t mipLevels;
		SampleCount sampleCount;
		TextureUsageFlags usage;
		TextureTiling tiling;
		TextureLayout initialLayout;
		HeapType heapType;

		TextureDesc() = default;

		TextureDesc(
			TextureType       type_,
			Format            format_= {},
			uint32_t          width_= {},
			uint32_t          height_= {},
			uint32_t          depthOrArrayLayers_= {},
			uint32_t          mipLevels_= {},
			SampleCount       sampleCount_= {},
			TextureUsageFlags usage_= {},
			TextureTiling     tiling_= {},
			TextureLayout     initialLayout_= {},
			HeapType          heapType_= {})
		  : type{ type_ }
		  , format{ format_ }
		  , width{ width_ }
		  , height{ height_ }
		  , depthOrArrayLayers{ depthOrArrayLayers_ }
		  , mipLevels{ mipLevels_ }
		  , sampleCount{ sampleCount_ }
		  , usage{ usage_ }
		  , tiling{ tiling_ }
		  , initialLayout{ initialLayout_ }
		  , heapType{ heapType_ } {}
		TextureDesc(const TextureDesc& other) = default;
		TextureDesc(const VgTextureDesc& other)
		  : TextureDesc(*reinterpret_cast<TextureDesc const*>(&other))
		{
		}

		constexpr TextureDesc& operator=(vg::TextureDesc const& other) noexcept = default;
		inline TextureDesc& operator=(VgTextureDesc const& other) noexcept
		{
			*this = *reinterpret_cast<vg::TextureDesc const*>(&other);
			return *this;
		}

		operator VgTextureDesc&() noexcept
		{
			return *reinterpret_cast<VgTextureDesc*>(this);
		}
		operator const VgTextureDesc&() const noexcept
		{
			return *reinterpret_cast<VgTextureDesc const*>(this);
		}

		auto operator<=>(TextureDesc const& other) const = default;
	};

	struct AttachmentViewDesc
	{
		using NativeType = VgAttachmentViewDesc;

		Format format;
		TextureAttachmentViewType type;
		uint32_t mip;
		uint32_t baseArrayLayer;
		uint32_t arrayLayers;

		AttachmentViewDesc() = default;

		AttachmentViewDesc(
			Format                    format_,
			TextureAttachmentViewType type_= {},
			uint32_t                  mip_= {},
			uint32_t                  baseArrayLayer_= {},
			uint32_t                  arrayLayers_= {})
		  : format{ format_ }
		  , type{ type_ }
		  , mip{ mip_ }
		  , baseArrayLayer{ baseArrayLayer_ }
		  , arrayLayers{ arrayLayers_ } {}
		AttachmentViewDesc(const AttachmentViewDesc& other) = default;
		AttachmentViewDesc(const VgAttachmentViewDesc& other)
		  : AttachmentViewDesc(*reinterpret_cast<AttachmentViewDesc const*>(&other))
		{
		}

		constexpr AttachmentViewDesc& operator=(vg::AttachmentViewDesc const& other) noexcept = default;
		inline AttachmentViewDesc& operator=(VgAttachmentViewDesc const& other) noexcept
		{
			*this = *reinterpret_cast<vg::AttachmentViewDesc const*>(&other);
			return *this;
		}

		operator VgAttachmentViewDesc&() noexcept
		{
			return *reinterpret_cast<VgAttachmentViewDesc*>(this);
		}
		operator const VgAttachmentViewDesc&() const noexcept
		{
			return *reinterpret_cast<VgAttachmentViewDesc const*>(this);
		}

		auto operator<=>(AttachmentViewDesc const& other) const = default;
	};

	struct AttachmentInfo
	{
		using NativeType = VgAttachmentInfo;

		AttachmentView view;
		TextureLayout viewLayout;
		uint32_t resolveView;
		ResolveMode resolveMode;
		TextureLayout resolveViewLayout;
		AttachmentOp loadOp;
		AttachmentOp storeOp;
		ClearValue clear;

		AttachmentInfo() = default;

		AttachmentInfo(
			AttachmentView view_,
			TextureLayout  viewLayout_= {},
			uint32_t       resolveView_= {},
			ResolveMode    resolveMode_= {},
			TextureLayout  resolveViewLayout_= {},
			AttachmentOp   loadOp_= {},
			AttachmentOp   storeOp_= {},
			ClearValue     clear_= {})
		  : view{ view_ }
		  , viewLayout{ viewLayout_ }
		  , resolveView{ resolveView_ }
		  , resolveMode{ resolveMode_ }
		  , resolveViewLayout{ resolveViewLayout_ }
		  , loadOp{ loadOp_ }
		  , storeOp{ storeOp_ }
		  , clear{ clear_ } {}
		AttachmentInfo(const AttachmentInfo& other) = default;
		AttachmentInfo(const VgAttachmentInfo& other)
		  : AttachmentInfo(*reinterpret_cast<AttachmentInfo const*>(&other))
		{
		}

		constexpr AttachmentInfo& operator=(vg::AttachmentInfo const& other) noexcept = default;
		inline AttachmentInfo& operator=(VgAttachmentInfo const& other) noexcept
		{
			*this = *reinterpret_cast<vg::AttachmentInfo const*>(&other);
			return *this;
		}

		operator VgAttachmentInfo&() noexcept
		{
			return *reinterpret_cast<VgAttachmentInfo*>(this);
		}
		operator const VgAttachmentInfo&() const noexcept
		{
			return *reinterpret_cast<VgAttachmentInfo const*>(this);
		}

		auto operator<=>(AttachmentInfo const& other) const = default;
	};

	struct RenderingInfo
	{
		using NativeType = VgRenderingInfo;

		uint32_t numColorAttachments;
		AttachmentInfo* colorAttachments;
		AttachmentInfo depthStencilAttachment;

		RenderingInfo() = default;

		RenderingInfo(
			uint32_t        numColorAttachments_,
			AttachmentInfo* colorAttachments_= {},
			AttachmentInfo  depthStencilAttachment_= {})
		  : numColorAttachments{ numColorAttachments_ }
		  , colorAttachments{ colorAttachments_ }
		  , depthStencilAttachment{ depthStencilAttachment_ } {}
		RenderingInfo(const RenderingInfo& other) = default;
		RenderingInfo(const VgRenderingInfo& other)
		  : RenderingInfo(*reinterpret_cast<RenderingInfo const*>(&other))
		{
		}

		constexpr RenderingInfo& operator=(vg::RenderingInfo const& other) noexcept = default;
		inline RenderingInfo& operator=(VgRenderingInfo const& other) noexcept
		{
			*this = *reinterpret_cast<vg::RenderingInfo const*>(&other);
			return *this;
		}

		operator VgRenderingInfo&() noexcept
		{
			return *reinterpret_cast<VgRenderingInfo*>(this);
		}
		operator const VgRenderingInfo&() const noexcept
		{
			return *reinterpret_cast<VgRenderingInfo const*>(this);
		}

		auto operator<=>(RenderingInfo const& other) const = default;
	};

	struct ComponentSwizzle
	{
		using NativeType = VgComponentSwizzle;

		ComponentMapping r;
		ComponentMapping g;
		ComponentMapping b;
		ComponentMapping a;

		ComponentSwizzle() = default;

		ComponentSwizzle(
			ComponentMapping r_,
			ComponentMapping g_= {},
			ComponentMapping b_= {},
			ComponentMapping a_= {})
		  : r{ r_ }
		  , g{ g_ }
		  , b{ b_ }
		  , a{ a_ } {}
		ComponentSwizzle(const ComponentSwizzle& other) = default;
		ComponentSwizzle(const VgComponentSwizzle& other)
		  : ComponentSwizzle(*reinterpret_cast<ComponentSwizzle const*>(&other))
		{
		}

		constexpr ComponentSwizzle& operator=(vg::ComponentSwizzle const& other) noexcept = default;
		inline ComponentSwizzle& operator=(VgComponentSwizzle const& other) noexcept
		{
			*this = *reinterpret_cast<vg::ComponentSwizzle const*>(&other);
			return *this;
		}

		operator VgComponentSwizzle&() noexcept
		{
			return *reinterpret_cast<VgComponentSwizzle*>(this);
		}
		operator const VgComponentSwizzle&() const noexcept
		{
			return *reinterpret_cast<VgComponentSwizzle const*>(this);
		}

		auto operator<=>(ComponentSwizzle const& other) const = default;
	};

	struct TextureViewDesc
	{
		using NativeType = VgTextureViewDesc;

		Format format;
		TextureViewType type;
		TextureDescriptorType descriptorType;
		ComponentSwizzle components;
		uint32_t baseMipLevel;
		uint32_t mipLevels;
		uint32_t baseArrayLayer;
		uint32_t arrayLayers;

		TextureViewDesc() = default;

		TextureViewDesc(
			Format                format_,
			TextureViewType       type_= {},
			TextureDescriptorType descriptorType_= {},
			ComponentSwizzle      components_= {},
			uint32_t              baseMipLevel_= {},
			uint32_t              mipLevels_= {},
			uint32_t              baseArrayLayer_= {},
			uint32_t              arrayLayers_= {})
		  : format{ format_ }
		  , type{ type_ }
		  , descriptorType{ descriptorType_ }
		  , components{ components_ }
		  , baseMipLevel{ baseMipLevel_ }
		  , mipLevels{ mipLevels_ }
		  , baseArrayLayer{ baseArrayLayer_ }
		  , arrayLayers{ arrayLayers_ } {}
		TextureViewDesc(const TextureViewDesc& other) = default;
		TextureViewDesc(const VgTextureViewDesc& other)
		  : TextureViewDesc(*reinterpret_cast<TextureViewDesc const*>(&other))
		{
		}

		constexpr TextureViewDesc& operator=(vg::TextureViewDesc const& other) noexcept = default;
		inline TextureViewDesc& operator=(VgTextureViewDesc const& other) noexcept
		{
			*this = *reinterpret_cast<vg::TextureViewDesc const*>(&other);
			return *this;
		}

		operator VgTextureViewDesc&() noexcept
		{
			return *reinterpret_cast<VgTextureViewDesc*>(this);
		}
		operator const VgTextureViewDesc&() const noexcept
		{
			return *reinterpret_cast<VgTextureViewDesc const*>(this);
		}

		auto operator<=>(TextureViewDesc const& other) const = default;
	};

	struct Offset
	{
		using NativeType = VgOffset;

		uint32_t x;
		uint32_t y;
		uint32_t z;

		Offset() = default;

		Offset(
			uint32_t x_,
			uint32_t y_= {},
			uint32_t z_= {})
		  : x{ x_ }
		  , y{ y_ }
		  , z{ z_ } {}
		Offset(const Offset& other) = default;
		Offset(const VgOffset& other)
		  : Offset(*reinterpret_cast<Offset const*>(&other))
		{
		}

		constexpr Offset& operator=(vg::Offset const& other) noexcept = default;
		inline Offset& operator=(VgOffset const& other) noexcept
		{
			*this = *reinterpret_cast<vg::Offset const*>(&other);
			return *this;
		}

		operator VgOffset&() noexcept
		{
			return *reinterpret_cast<VgOffset*>(this);
		}
		operator const VgOffset&() const noexcept
		{
			return *reinterpret_cast<VgOffset const*>(this);
		}

		auto operator<=>(Offset const& other) const = default;
	};

	struct Region
	{
		using NativeType = VgRegion;

		uint32_t mip;
		uint32_t baseArrayLayer;
		uint32_t arrayLayers;
		Offset offset;
		uint32_t width;
		uint32_t height;
		uint32_t depth;

		Region() = default;

		Region(
			uint32_t mip_,
			uint32_t baseArrayLayer_= {},
			uint32_t arrayLayers_= {},
			Offset   offset_= {},
			uint32_t width_= {},
			uint32_t height_= {},
			uint32_t depth_= {})
		  : mip{ mip_ }
		  , baseArrayLayer{ baseArrayLayer_ }
		  , arrayLayers{ arrayLayers_ }
		  , offset{ offset_ }
		  , width{ width_ }
		  , height{ height_ }
		  , depth{ depth_ } {}
		Region(const Region& other) = default;
		Region(const VgRegion& other)
		  : Region(*reinterpret_cast<Region const*>(&other))
		{
		}

		constexpr Region& operator=(vg::Region const& other) noexcept = default;
		inline Region& operator=(VgRegion const& other) noexcept
		{
			*this = *reinterpret_cast<vg::Region const*>(&other);
			return *this;
		}

		operator VgRegion&() noexcept
		{
			return *reinterpret_cast<VgRegion*>(this);
		}
		operator const VgRegion&() const noexcept
		{
			return *reinterpret_cast<VgRegion const*>(this);
		}

		auto operator<=>(Region const& other) const = default;
	};

	struct SwapChainDesc
	{
		using NativeType = VgSwapChainDesc;

		uint32_t width;
		uint32_t height;
		Format format;
		uint32_t bufferCount;
		Surface surface;

		SwapChainDesc() = default;

		SwapChainDesc(
			uint32_t width_,
			uint32_t height_= {},
			Format   format_= {},
			uint32_t bufferCount_= {},
			Surface  surface_= {})
		  : width{ width_ }
		  , height{ height_ }
		  , format{ format_ }
		  , bufferCount{ bufferCount_ }
		  , surface{ surface_ } {}
		SwapChainDesc(const SwapChainDesc& other) = default;
		SwapChainDesc(const VgSwapChainDesc& other)
		  : SwapChainDesc(*reinterpret_cast<SwapChainDesc const*>(&other))
		{
		}

		constexpr SwapChainDesc& operator=(vg::SwapChainDesc const& other) noexcept = default;
		inline SwapChainDesc& operator=(VgSwapChainDesc const& other) noexcept
		{
			*this = *reinterpret_cast<vg::SwapChainDesc const*>(&other);
			return *this;
		}

		operator VgSwapChainDesc&() noexcept
		{
			return *reinterpret_cast<VgSwapChainDesc*>(this);
		}
		operator const VgSwapChainDesc&() const noexcept
		{
			return *reinterpret_cast<VgSwapChainDesc const*>(this);
		}

		auto operator<=>(SwapChainDesc const& other) const = default;
	};

	struct VertexAttribute
	{
		using NativeType = VgVertexAttribute;

		Format format;
		uint32_t offset;
		uint32_t vertexBufferIndex;
		AttributeInputRate inputRate;
		uint32_t instanceStepRate;

		VertexAttribute() = default;

		VertexAttribute(
			Format             format_,
			uint32_t           offset_= {},
			uint32_t           vertexBufferIndex_= {},
			AttributeInputRate inputRate_= {},
			uint32_t           instanceStepRate_= {})
		  : format{ format_ }
		  , offset{ offset_ }
		  , vertexBufferIndex{ vertexBufferIndex_ }
		  , inputRate{ inputRate_ }
		  , instanceStepRate{ instanceStepRate_ } {}
		VertexAttribute(const VertexAttribute& other) = default;
		VertexAttribute(const VgVertexAttribute& other)
		  : VertexAttribute(*reinterpret_cast<VertexAttribute const*>(&other))
		{
		}

		constexpr VertexAttribute& operator=(vg::VertexAttribute const& other) noexcept = default;
		inline VertexAttribute& operator=(VgVertexAttribute const& other) noexcept
		{
			*this = *reinterpret_cast<vg::VertexAttribute const*>(&other);
			return *this;
		}

		operator VgVertexAttribute&() noexcept
		{
			return *reinterpret_cast<VgVertexAttribute*>(this);
		}
		operator const VgVertexAttribute&() const noexcept
		{
			return *reinterpret_cast<VgVertexAttribute const*>(this);
		}

		auto operator<=>(VertexAttribute const& other) const = default;
	};

	struct FixedFunctionState
	{
		using NativeType = VgFixedFunctionState;

		uint32_t numVertexAttributes;
		VertexAttribute* vertexAttributes;
		ShaderModule vertexShader;
		ShaderModule hullShader;
		ShaderModule domainShader;
		ShaderModule geometryShader;

		FixedFunctionState() = default;

		FixedFunctionState(
			uint32_t         numVertexAttributes_,
			VertexAttribute* vertexAttributes_= {},
			ShaderModule     vertexShader_= {},
			ShaderModule     hullShader_= {},
			ShaderModule     domainShader_= {},
			ShaderModule     geometryShader_= {})
		  : numVertexAttributes{ numVertexAttributes_ }
		  , vertexAttributes{ vertexAttributes_ }
		  , vertexShader{ vertexShader_ }
		  , hullShader{ hullShader_ }
		  , domainShader{ domainShader_ }
		  , geometryShader{ geometryShader_ } {}
		FixedFunctionState(const FixedFunctionState& other) = default;
		FixedFunctionState(const VgFixedFunctionState& other)
		  : FixedFunctionState(*reinterpret_cast<FixedFunctionState const*>(&other))
		{
		}

		constexpr FixedFunctionState& operator=(vg::FixedFunctionState const& other) noexcept = default;
		inline FixedFunctionState& operator=(VgFixedFunctionState const& other) noexcept
		{
			*this = *reinterpret_cast<vg::FixedFunctionState const*>(&other);
			return *this;
		}

		operator VgFixedFunctionState&() noexcept
		{
			return *reinterpret_cast<VgFixedFunctionState*>(this);
		}
		operator const VgFixedFunctionState&() const noexcept
		{
			return *reinterpret_cast<VgFixedFunctionState const*>(this);
		}

		auto operator<=>(FixedFunctionState const& other) const = default;
	};

	struct MeshShaderState
	{
		using NativeType = VgMeshShaderState;

		ShaderModule amplificationShader;
		ShaderModule meshShader;

		MeshShaderState() = default;

		MeshShaderState(
			ShaderModule amplificationShader_,
			ShaderModule meshShader_= {})
		  : amplificationShader{ amplificationShader_ }
		  , meshShader{ meshShader_ } {}
		MeshShaderState(const MeshShaderState& other) = default;
		MeshShaderState(const VgMeshShaderState& other)
		  : MeshShaderState(*reinterpret_cast<MeshShaderState const*>(&other))
		{
		}

		constexpr MeshShaderState& operator=(vg::MeshShaderState const& other) noexcept = default;
		inline MeshShaderState& operator=(VgMeshShaderState const& other) noexcept
		{
			*this = *reinterpret_cast<vg::MeshShaderState const*>(&other);
			return *this;
		}

		operator VgMeshShaderState&() noexcept
		{
			return *reinterpret_cast<VgMeshShaderState*>(this);
		}
		operator const VgMeshShaderState&() const noexcept
		{
			return *reinterpret_cast<VgMeshShaderState const*>(this);
		}

		auto operator<=>(MeshShaderState const& other) const = default;
	};

	struct RasterizationState
	{
		using NativeType = VgRasterizationState;

		FillMode fillMode;
		CullMode cullMode;
		FrontFace frontFace;
		DepthClipMode depthClipMode;
		int32_t depthBias;
		float depthBiasClamp;
		float depthBiasSlopeFactor;
		bool conservativeRasterizationEnable;
		bool rasterizationDiscardEnable;

		RasterizationState() = default;

		RasterizationState(
			FillMode      fillMode_,
			CullMode      cullMode_= {},
			FrontFace     frontFace_= {},
			DepthClipMode depthClipMode_= {},
			int32_t       depthBias_= {},
			float         depthBiasClamp_= {},
			float         depthBiasSlopeFactor_= {},
			bool          conservativeRasterizationEnable_= {},
			bool          rasterizationDiscardEnable_= {})
		  : fillMode{ fillMode_ }
		  , cullMode{ cullMode_ }
		  , frontFace{ frontFace_ }
		  , depthClipMode{ depthClipMode_ }
		  , depthBias{ depthBias_ }
		  , depthBiasClamp{ depthBiasClamp_ }
		  , depthBiasSlopeFactor{ depthBiasSlopeFactor_ }
		  , conservativeRasterizationEnable{ conservativeRasterizationEnable_ }
		  , rasterizationDiscardEnable{ rasterizationDiscardEnable_ } {}
		RasterizationState(const RasterizationState& other) = default;
		RasterizationState(const VgRasterizationState& other)
		  : RasterizationState(*reinterpret_cast<RasterizationState const*>(&other))
		{
		}

		constexpr RasterizationState& operator=(vg::RasterizationState const& other) noexcept = default;
		inline RasterizationState& operator=(VgRasterizationState const& other) noexcept
		{
			*this = *reinterpret_cast<vg::RasterizationState const*>(&other);
			return *this;
		}

		operator VgRasterizationState&() noexcept
		{
			return *reinterpret_cast<VgRasterizationState*>(this);
		}
		operator const VgRasterizationState&() const noexcept
		{
			return *reinterpret_cast<VgRasterizationState const*>(this);
		}

		auto operator<=>(RasterizationState const& other) const = default;
	};

	struct StencilState
	{
		using NativeType = VgStencilState;

		StencilOp failOp;
		StencilOp depthFailOp;
		StencilOp passOp;
		CompareOp compareOp;

		StencilState() = default;

		StencilState(
			StencilOp failOp_,
			StencilOp depthFailOp_= {},
			StencilOp passOp_= {},
			CompareOp compareOp_= {})
		  : failOp{ failOp_ }
		  , depthFailOp{ depthFailOp_ }
		  , passOp{ passOp_ }
		  , compareOp{ compareOp_ } {}
		StencilState(const StencilState& other) = default;
		StencilState(const VgStencilState& other)
		  : StencilState(*reinterpret_cast<StencilState const*>(&other))
		{
		}

		constexpr StencilState& operator=(vg::StencilState const& other) noexcept = default;
		inline StencilState& operator=(VgStencilState const& other) noexcept
		{
			*this = *reinterpret_cast<vg::StencilState const*>(&other);
			return *this;
		}

		operator VgStencilState&() noexcept
		{
			return *reinterpret_cast<VgStencilState*>(this);
		}
		operator const VgStencilState&() const noexcept
		{
			return *reinterpret_cast<VgStencilState const*>(this);
		}

		auto operator<=>(StencilState const& other) const = default;
	};

	struct DepthStencilState
	{
		using NativeType = VgDepthStencilState;

		bool depthTestEnable;
		bool depthWriteEnable;
		CompareOp depthCompareOp;
		bool stencilTestEnable;
		StencilState front;
		StencilState back;
		uint32_t stencilReadMask;
		uint32_t stencilWriteMask;
		uint32_t stencilReference;
		bool depthBoundsTestEnable;
		float minDepthBounds;
		float maxDepthBounds;

		DepthStencilState() = default;

		DepthStencilState(
			bool         depthTestEnable_,
			bool         depthWriteEnable_= {},
			CompareOp    depthCompareOp_= {},
			bool         stencilTestEnable_= {},
			StencilState front_= {},
			StencilState back_= {},
			uint32_t     stencilReadMask_= {},
			uint32_t     stencilWriteMask_= {},
			uint32_t     stencilReference_= {},
			bool         depthBoundsTestEnable_= {},
			float        minDepthBounds_= {},
			float        maxDepthBounds_= {})
		  : depthTestEnable{ depthTestEnable_ }
		  , depthWriteEnable{ depthWriteEnable_ }
		  , depthCompareOp{ depthCompareOp_ }
		  , stencilTestEnable{ stencilTestEnable_ }
		  , front{ front_ }
		  , back{ back_ }
		  , stencilReadMask{ stencilReadMask_ }
		  , stencilWriteMask{ stencilWriteMask_ }
		  , stencilReference{ stencilReference_ }
		  , depthBoundsTestEnable{ depthBoundsTestEnable_ }
		  , minDepthBounds{ minDepthBounds_ }
		  , maxDepthBounds{ maxDepthBounds_ } {}
		DepthStencilState(const DepthStencilState& other) = default;
		DepthStencilState(const VgDepthStencilState& other)
		  : DepthStencilState(*reinterpret_cast<DepthStencilState const*>(&other))
		{
		}

		constexpr DepthStencilState& operator=(vg::DepthStencilState const& other) noexcept = default;
		inline DepthStencilState& operator=(VgDepthStencilState const& other) noexcept
		{
			*this = *reinterpret_cast<vg::DepthStencilState const*>(&other);
			return *this;
		}

		operator VgDepthStencilState&() noexcept
		{
			return *reinterpret_cast<VgDepthStencilState*>(this);
		}
		operator const VgDepthStencilState&() const noexcept
		{
			return *reinterpret_cast<VgDepthStencilState const*>(this);
		}

		auto operator<=>(DepthStencilState const& other) const = default;
	};

	struct MultisamplingState
	{
		using NativeType = VgMultisamplingState;

		SampleCount sampleCount;
		bool alphaToCoverage;

		MultisamplingState() = default;

		MultisamplingState(
			SampleCount sampleCount_,
			bool        alphaToCoverage_= {})
		  : sampleCount{ sampleCount_ }
		  , alphaToCoverage{ alphaToCoverage_ } {}
		MultisamplingState(const MultisamplingState& other) = default;
		MultisamplingState(const VgMultisamplingState& other)
		  : MultisamplingState(*reinterpret_cast<MultisamplingState const*>(&other))
		{
		}

		constexpr MultisamplingState& operator=(vg::MultisamplingState const& other) noexcept = default;
		inline MultisamplingState& operator=(VgMultisamplingState const& other) noexcept
		{
			*this = *reinterpret_cast<vg::MultisamplingState const*>(&other);
			return *this;
		}

		operator VgMultisamplingState&() noexcept
		{
			return *reinterpret_cast<VgMultisamplingState*>(this);
		}
		operator const VgMultisamplingState&() const noexcept
		{
			return *reinterpret_cast<VgMultisamplingState const*>(this);
		}

		auto operator<=>(MultisamplingState const& other) const = default;
	};

	struct AttachmentBlendState
	{
		using NativeType = VgAttachmentBlendState;

		bool blendEnable;
		BlendFactor srcColor;
		BlendFactor dstColor;
		BlendOp colorOp;
		BlendFactor srcAlpha;
		BlendFactor dstAlpha;
		BlendOp alphaOp;
		ColorComponentFlags colorWriteMask;

		AttachmentBlendState() = default;

		AttachmentBlendState(
			bool                blendEnable_,
			BlendFactor         srcColor_= {},
			BlendFactor         dstColor_= {},
			BlendOp             colorOp_= {},
			BlendFactor         srcAlpha_= {},
			BlendFactor         dstAlpha_= {},
			BlendOp             alphaOp_= {},
			ColorComponentFlags colorWriteMask_= {})
		  : blendEnable{ blendEnable_ }
		  , srcColor{ srcColor_ }
		  , dstColor{ dstColor_ }
		  , colorOp{ colorOp_ }
		  , srcAlpha{ srcAlpha_ }
		  , dstAlpha{ dstAlpha_ }
		  , alphaOp{ alphaOp_ }
		  , colorWriteMask{ colorWriteMask_ } {}
		AttachmentBlendState(const AttachmentBlendState& other) = default;
		AttachmentBlendState(const VgAttachmentBlendState& other)
		  : AttachmentBlendState(*reinterpret_cast<AttachmentBlendState const*>(&other))
		{
		}

		constexpr AttachmentBlendState& operator=(vg::AttachmentBlendState const& other) noexcept = default;
		inline AttachmentBlendState& operator=(VgAttachmentBlendState const& other) noexcept
		{
			*this = *reinterpret_cast<vg::AttachmentBlendState const*>(&other);
			return *this;
		}

		operator VgAttachmentBlendState&() noexcept
		{
			return *reinterpret_cast<VgAttachmentBlendState*>(this);
		}
		operator const VgAttachmentBlendState&() const noexcept
		{
			return *reinterpret_cast<VgAttachmentBlendState const*>(this);
		}

		auto operator<=>(AttachmentBlendState const& other) const = default;
	};

	struct BlendState
	{
		using NativeType = VgBlendState;

		bool logicOpEnable;
		LogicOp logicOp;
		AttachmentBlendState attachments[vg_num_max_color_attachments];
		float blendConstants[4];

		BlendState() = default;

		BlendState(
			bool                 logicOpEnable_,
			LogicOp              logicOp_= {},
			AttachmentBlendState attachments_= {},
			float                blendConstants_= {})
		  : logicOpEnable{ logicOpEnable_ }
		  , logicOp{ logicOp_ }
		  , attachments{ attachments_ }
		  , blendConstants{ blendConstants_ } {}
		BlendState(const BlendState& other) = default;
		BlendState(const VgBlendState& other)
		  : BlendState(*reinterpret_cast<BlendState const*>(&other))
		{
		}

		constexpr BlendState& operator=(vg::BlendState const& other) noexcept = default;
		inline BlendState& operator=(VgBlendState const& other) noexcept
		{
			*this = *reinterpret_cast<vg::BlendState const*>(&other);
			return *this;
		}

		operator VgBlendState&() noexcept
		{
			return *reinterpret_cast<VgBlendState*>(this);
		}
		operator const VgBlendState&() const noexcept
		{
			return *reinterpret_cast<VgBlendState const*>(this);
		}

		auto operator<=>(BlendState const& other) const = default;
	};

	struct GraphicsPipelineDesc
	{
		using NativeType = VgGraphicsPipelineDesc;

		VertexPipeline vertexPipelineType;
		FixedFunctionState fixedFunction;
		MeshShaderState mesh;
		ShaderModule pixelShader;
		PrimitiveTopology primitiveTopology;
		bool primitiveRestartEnable;
		uint32_t tesselationControlPoints;
		RasterizationState rasterizationState;
		MultisamplingState multisamplingState;
		DepthStencilState depthStencilState;
		uint32_t numColorAttachments;
		Format colorAttachmentFormats[vg_num_max_color_attachments];
		Format depthStencilFormat;
		BlendState blendState;

		GraphicsPipelineDesc() = default;

		GraphicsPipelineDesc(
			VertexPipeline     vertexPipelineType_,
			FixedFunctionState fixedFunction_= {},
			MeshShaderState    mesh_= {},
			ShaderModule       pixelShader_= {},
			PrimitiveTopology  primitiveTopology_= {},
			bool               primitiveRestartEnable_= {},
			uint32_t           tesselationControlPoints_= {},
			RasterizationState rasterizationState_= {},
			MultisamplingState multisamplingState_= {},
			DepthStencilState  depthStencilState_= {},
			uint32_t           numColorAttachments_= {},
			Format             colorAttachmentFormats_= {},
			Format             depthStencilFormat_= {},
			BlendState         blendState_= {})
		  : vertexPipelineType{ vertexPipelineType_ }
		  , fixedFunction{ fixedFunction_ }
		  , mesh{ mesh_ }
		  , pixelShader{ pixelShader_ }
		  , primitiveTopology{ primitiveTopology_ }
		  , primitiveRestartEnable{ primitiveRestartEnable_ }
		  , tesselationControlPoints{ tesselationControlPoints_ }
		  , rasterizationState{ rasterizationState_ }
		  , multisamplingState{ multisamplingState_ }
		  , depthStencilState{ depthStencilState_ }
		  , numColorAttachments{ numColorAttachments_ }
		  , colorAttachmentFormats{ colorAttachmentFormats_ }
		  , depthStencilFormat{ depthStencilFormat_ }
		  , blendState{ blendState_ } {}
		GraphicsPipelineDesc(const GraphicsPipelineDesc& other) = default;
		GraphicsPipelineDesc(const VgGraphicsPipelineDesc& other)
		  : GraphicsPipelineDesc(*reinterpret_cast<GraphicsPipelineDesc const*>(&other))
		{
		}

		constexpr GraphicsPipelineDesc& operator=(vg::GraphicsPipelineDesc const& other) noexcept = default;
		inline GraphicsPipelineDesc& operator=(VgGraphicsPipelineDesc const& other) noexcept
		{
			*this = *reinterpret_cast<vg::GraphicsPipelineDesc const*>(&other);
			return *this;
		}

		operator VgGraphicsPipelineDesc&() noexcept
		{
			return *reinterpret_cast<VgGraphicsPipelineDesc*>(this);
		}
		operator const VgGraphicsPipelineDesc&() const noexcept
		{
			return *reinterpret_cast<VgGraphicsPipelineDesc const*>(this);
		}

		auto operator<=>(GraphicsPipelineDesc const& other) const = default;
	};

	struct Viewport
	{
		using NativeType = VgViewport;

		float x;
		float y;
		float width;
		float height;
		float minDepth;
		float maxDepth;

		Viewport() = default;

		Viewport(
			float x_,
			float y_= {},
			float width_= {},
			float height_= {},
			float minDepth_= {},
			float maxDepth_= {})
		  : x{ x_ }
		  , y{ y_ }
		  , width{ width_ }
		  , height{ height_ }
		  , minDepth{ minDepth_ }
		  , maxDepth{ maxDepth_ } {}
		Viewport(const Viewport& other) = default;
		Viewport(const VgViewport& other)
		  : Viewport(*reinterpret_cast<Viewport const*>(&other))
		{
		}

		constexpr Viewport& operator=(vg::Viewport const& other) noexcept = default;
		inline Viewport& operator=(VgViewport const& other) noexcept
		{
			*this = *reinterpret_cast<vg::Viewport const*>(&other);
			return *this;
		}

		operator VgViewport&() noexcept
		{
			return *reinterpret_cast<VgViewport*>(this);
		}
		operator const VgViewport&() const noexcept
		{
			return *reinterpret_cast<VgViewport const*>(this);
		}

		auto operator<=>(Viewport const& other) const = default;
	};

	struct Scissor
	{
		using NativeType = VgScissor;

		uint32_t x;
		uint32_t y;
		uint32_t width;
		uint32_t height;

		Scissor() = default;

		Scissor(
			uint32_t x_,
			uint32_t y_= {},
			uint32_t width_= {},
			uint32_t height_= {})
		  : x{ x_ }
		  , y{ y_ }
		  , width{ width_ }
		  , height{ height_ } {}
		Scissor(const Scissor& other) = default;
		Scissor(const VgScissor& other)
		  : Scissor(*reinterpret_cast<Scissor const*>(&other))
		{
		}

		constexpr Scissor& operator=(vg::Scissor const& other) noexcept = default;
		inline Scissor& operator=(VgScissor const& other) noexcept
		{
			*this = *reinterpret_cast<vg::Scissor const*>(&other);
			return *this;
		}

		operator VgScissor&() noexcept
		{
			return *reinterpret_cast<VgScissor*>(this);
		}
		operator const VgScissor&() const noexcept
		{
			return *reinterpret_cast<VgScissor const*>(this);
		}

		auto operator<=>(Scissor const& other) const = default;
	};

	struct MemoryStatistics
	{
		using NativeType = VgMemoryStatistics;

		uint64_t numBuffers;
		uint64_t numTextures;
		uint64_t numPipelines;
		uint64_t usedVram;

		MemoryStatistics() = default;

		MemoryStatistics(
			uint64_t numBuffers_,
			uint64_t numTextures_= {},
			uint64_t numPipelines_= {},
			uint64_t usedVram_= {})
		  : numBuffers{ numBuffers_ }
		  , numTextures{ numTextures_ }
		  , numPipelines{ numPipelines_ }
		  , usedVram{ usedVram_ } {}
		MemoryStatistics(const MemoryStatistics& other) = default;
		MemoryStatistics(const VgMemoryStatistics& other)
		  : MemoryStatistics(*reinterpret_cast<MemoryStatistics const*>(&other))
		{
		}

		constexpr MemoryStatistics& operator=(vg::MemoryStatistics const& other) noexcept = default;
		inline MemoryStatistics& operator=(VgMemoryStatistics const& other) noexcept
		{
			*this = *reinterpret_cast<vg::MemoryStatistics const*>(&other);
			return *this;
		}

		operator VgMemoryStatistics&() noexcept
		{
			return *reinterpret_cast<VgMemoryStatistics*>(this);
		}
		operator const VgMemoryStatistics&() const noexcept
		{
			return *reinterpret_cast<VgMemoryStatistics const*>(this);
		}

		auto operator<=>(MemoryStatistics const& other) const = default;
	};

	struct DrawIndirectCommand
	{
		using NativeType = VgDrawIndirectCommand;

		uint32_t vertexCount;
		uint32_t instanceCount;
		uint32_t fisrtVertex;
		uint32_t firstInstance;

		DrawIndirectCommand() = default;

		DrawIndirectCommand(
			uint32_t vertexCount_,
			uint32_t instanceCount_= {},
			uint32_t fisrtVertex_= {},
			uint32_t firstInstance_= {})
		  : vertexCount{ vertexCount_ }
		  , instanceCount{ instanceCount_ }
		  , fisrtVertex{ fisrtVertex_ }
		  , firstInstance{ firstInstance_ } {}
		DrawIndirectCommand(const DrawIndirectCommand& other) = default;
		DrawIndirectCommand(const VgDrawIndirectCommand& other)
		  : DrawIndirectCommand(*reinterpret_cast<DrawIndirectCommand const*>(&other))
		{
		}

		constexpr DrawIndirectCommand& operator=(vg::DrawIndirectCommand const& other) noexcept = default;
		inline DrawIndirectCommand& operator=(VgDrawIndirectCommand const& other) noexcept
		{
			*this = *reinterpret_cast<vg::DrawIndirectCommand const*>(&other);
			return *this;
		}

		operator VgDrawIndirectCommand&() noexcept
		{
			return *reinterpret_cast<VgDrawIndirectCommand*>(this);
		}
		operator const VgDrawIndirectCommand&() const noexcept
		{
			return *reinterpret_cast<VgDrawIndirectCommand const*>(this);
		}

		auto operator<=>(DrawIndirectCommand const& other) const = default;
	};

	struct DrawIndexedIndirectCommand
	{
		using NativeType = VgDrawIndexedIndirectCommand;

		uint32_t indexCount;
		uint32_t instanceCount;
		uint32_t firstIndex;
		uint32_t vertexOffset;
		uint32_t firstInstace;

		DrawIndexedIndirectCommand() = default;

		DrawIndexedIndirectCommand(
			uint32_t indexCount_,
			uint32_t instanceCount_= {},
			uint32_t firstIndex_= {},
			uint32_t vertexOffset_= {},
			uint32_t firstInstace_= {})
		  : indexCount{ indexCount_ }
		  , instanceCount{ instanceCount_ }
		  , firstIndex{ firstIndex_ }
		  , vertexOffset{ vertexOffset_ }
		  , firstInstace{ firstInstace_ } {}
		DrawIndexedIndirectCommand(const DrawIndexedIndirectCommand& other) = default;
		DrawIndexedIndirectCommand(const VgDrawIndexedIndirectCommand& other)
		  : DrawIndexedIndirectCommand(*reinterpret_cast<DrawIndexedIndirectCommand const*>(&other))
		{
		}

		constexpr DrawIndexedIndirectCommand& operator=(vg::DrawIndexedIndirectCommand const& other) noexcept = default;
		inline DrawIndexedIndirectCommand& operator=(VgDrawIndexedIndirectCommand const& other) noexcept
		{
			*this = *reinterpret_cast<vg::DrawIndexedIndirectCommand const*>(&other);
			return *this;
		}

		operator VgDrawIndexedIndirectCommand&() noexcept
		{
			return *reinterpret_cast<VgDrawIndexedIndirectCommand*>(this);
		}
		operator const VgDrawIndexedIndirectCommand&() const noexcept
		{
			return *reinterpret_cast<VgDrawIndexedIndirectCommand const*>(this);
		}

		auto operator<=>(DrawIndexedIndirectCommand const& other) const = default;
	};

	struct DispatchIndirectCommand
	{
		using NativeType = VgDispatchIndirectCommand;

		uint32_t groupsX;
		uint32_t groupsY;
		uint32_t groupsZ;

		DispatchIndirectCommand() = default;

		DispatchIndirectCommand(
			uint32_t groupsX_,
			uint32_t groupsY_= {},
			uint32_t groupsZ_= {})
		  : groupsX{ groupsX_ }
		  , groupsY{ groupsY_ }
		  , groupsZ{ groupsZ_ } {}
		DispatchIndirectCommand(const DispatchIndirectCommand& other) = default;
		DispatchIndirectCommand(const VgDispatchIndirectCommand& other)
		  : DispatchIndirectCommand(*reinterpret_cast<DispatchIndirectCommand const*>(&other))
		{
		}

		constexpr DispatchIndirectCommand& operator=(vg::DispatchIndirectCommand const& other) noexcept = default;
		inline DispatchIndirectCommand& operator=(VgDispatchIndirectCommand const& other) noexcept
		{
			*this = *reinterpret_cast<vg::DispatchIndirectCommand const*>(&other);
			return *this;
		}

		operator VgDispatchIndirectCommand&() noexcept
		{
			return *reinterpret_cast<VgDispatchIndirectCommand*>(this);
		}
		operator const VgDispatchIndirectCommand&() const noexcept
		{
			return *reinterpret_cast<VgDispatchIndirectCommand const*>(this);
		}

		auto operator<=>(DispatchIndirectCommand const& other) const = default;
	};

	struct VulkanObjects
	{
		using NativeType = VgVulkanObjects;

		VkInstance_T* instance;
		const VkAllocationCallbacks* allocationCallbacks;

		VulkanObjects() = default;

		VulkanObjects(
			VkInstance_T*                instance_,
			const VkAllocationCallbacks* allocationCallbacks_= {})
		  : instance{ instance_ }
		  , allocationCallbacks{ allocationCallbacks_ } {}
		VulkanObjects(const VulkanObjects& other) = default;
		VulkanObjects(const VgVulkanObjects& other)
		  : VulkanObjects(*reinterpret_cast<VulkanObjects const*>(&other))
		{
		}

		constexpr VulkanObjects& operator=(vg::VulkanObjects const& other) noexcept = default;
		inline VulkanObjects& operator=(VgVulkanObjects const& other) noexcept
		{
			*this = *reinterpret_cast<vg::VulkanObjects const*>(&other);
			return *this;
		}

		operator VgVulkanObjects&() noexcept
		{
			return *reinterpret_cast<VgVulkanObjects*>(this);
		}
		operator const VgVulkanObjects&() const noexcept
		{
			return *reinterpret_cast<VgVulkanObjects const*>(this);
		}

		auto operator<=>(VulkanObjects const& other) const = default;
	};



	constexpr InitFlags operator|(InitFlags a, InitFlags b) { return static_cast<InitFlags>(static_cast<std::underlying_type_t<InitFlags>>(a) | static_cast<std::underlying_type_t<InitFlags>>(b)); }
	constexpr InitFlags& operator|=(InitFlags& a, InitFlags b) { a = a | b; return a; }
	constexpr InitFlags operator&(InitFlags a, InitFlags b) { return static_cast<InitFlags>(static_cast<std::underlying_type_t<InitFlags>>(a) & static_cast<std::underlying_type_t<InitFlags>>(b)); }
	constexpr InitFlags& operator&=(InitFlags& a, InitFlags b) { a = a & b; return a; }
	constexpr InitFlags operator^(InitFlags a, InitFlags b) { return static_cast<InitFlags>(static_cast<std::underlying_type_t<InitFlags>>(a) ^ static_cast<std::underlying_type_t<InitFlags>>(b)); }
	constexpr InitFlags& operator^=(InitFlags& a, InitFlags b) { a = a ^ b; return a; }
	constexpr InitFlags operator<<(InitFlags a, std::underlying_type_t<InitFlags> b) { return static_cast<InitFlags>(static_cast<std::underlying_type_t<InitFlags>>(a) << b); }
	constexpr InitFlags operator<<(InitFlags a, InitFlags b) { return static_cast<InitFlags>(static_cast<std::underlying_type_t<InitFlags>>(a) << static_cast<std::underlying_type_t<InitFlags>>(b)); }
	constexpr InitFlags& operator<<=(InitFlags& a, InitFlags b) { a = a << b; return a; }
	constexpr InitFlags operator>>(InitFlags a, std::underlying_type_t<InitFlags> b) { return static_cast<InitFlags>(static_cast<std::underlying_type_t<InitFlags>>(a) >> b); }
	constexpr InitFlags operator>>(InitFlags a, InitFlags b) { return static_cast<InitFlags>(static_cast<std::underlying_type_t<InitFlags>>(a) >> static_cast<std::underlying_type_t<InitFlags>>(b)); }
	constexpr InitFlags& operator>>=(InitFlags& a, InitFlags b) { a = a >> b; return a; }
	constexpr InitFlags operator~(InitFlags a) { return static_cast<InitFlags>(~static_cast<std::underlying_type_t<InitFlags>>(a)); }


	constexpr CommandPoolFlags operator|(CommandPoolFlags a, CommandPoolFlags b) { return static_cast<CommandPoolFlags>(static_cast<std::underlying_type_t<CommandPoolFlags>>(a) | static_cast<std::underlying_type_t<CommandPoolFlags>>(b)); }
	constexpr CommandPoolFlags& operator|=(CommandPoolFlags& a, CommandPoolFlags b) { a = a | b; return a; }
	constexpr CommandPoolFlags operator&(CommandPoolFlags a, CommandPoolFlags b) { return static_cast<CommandPoolFlags>(static_cast<std::underlying_type_t<CommandPoolFlags>>(a) & static_cast<std::underlying_type_t<CommandPoolFlags>>(b)); }
	constexpr CommandPoolFlags& operator&=(CommandPoolFlags& a, CommandPoolFlags b) { a = a & b; return a; }
	constexpr CommandPoolFlags operator^(CommandPoolFlags a, CommandPoolFlags b) { return static_cast<CommandPoolFlags>(static_cast<std::underlying_type_t<CommandPoolFlags>>(a) ^ static_cast<std::underlying_type_t<CommandPoolFlags>>(b)); }
	constexpr CommandPoolFlags& operator^=(CommandPoolFlags& a, CommandPoolFlags b) { a = a ^ b; return a; }
	constexpr CommandPoolFlags operator<<(CommandPoolFlags a, std::underlying_type_t<CommandPoolFlags> b) { return static_cast<CommandPoolFlags>(static_cast<std::underlying_type_t<CommandPoolFlags>>(a) << b); }
	constexpr CommandPoolFlags operator<<(CommandPoolFlags a, CommandPoolFlags b) { return static_cast<CommandPoolFlags>(static_cast<std::underlying_type_t<CommandPoolFlags>>(a) << static_cast<std::underlying_type_t<CommandPoolFlags>>(b)); }
	constexpr CommandPoolFlags& operator<<=(CommandPoolFlags& a, CommandPoolFlags b) { a = a << b; return a; }
	constexpr CommandPoolFlags operator>>(CommandPoolFlags a, std::underlying_type_t<CommandPoolFlags> b) { return static_cast<CommandPoolFlags>(static_cast<std::underlying_type_t<CommandPoolFlags>>(a) >> b); }
	constexpr CommandPoolFlags operator>>(CommandPoolFlags a, CommandPoolFlags b) { return static_cast<CommandPoolFlags>(static_cast<std::underlying_type_t<CommandPoolFlags>>(a) >> static_cast<std::underlying_type_t<CommandPoolFlags>>(b)); }
	constexpr CommandPoolFlags& operator>>=(CommandPoolFlags& a, CommandPoolFlags b) { a = a >> b; return a; }
	constexpr CommandPoolFlags operator~(CommandPoolFlags a) { return static_cast<CommandPoolFlags>(~static_cast<std::underlying_type_t<CommandPoolFlags>>(a)); }


	constexpr PipelineStageFlags operator|(PipelineStageFlags a, PipelineStageFlags b) { return static_cast<PipelineStageFlags>(static_cast<std::underlying_type_t<PipelineStageFlags>>(a) | static_cast<std::underlying_type_t<PipelineStageFlags>>(b)); }
	constexpr PipelineStageFlags& operator|=(PipelineStageFlags& a, PipelineStageFlags b) { a = a | b; return a; }
	constexpr PipelineStageFlags operator&(PipelineStageFlags a, PipelineStageFlags b) { return static_cast<PipelineStageFlags>(static_cast<std::underlying_type_t<PipelineStageFlags>>(a) & static_cast<std::underlying_type_t<PipelineStageFlags>>(b)); }
	constexpr PipelineStageFlags& operator&=(PipelineStageFlags& a, PipelineStageFlags b) { a = a & b; return a; }
	constexpr PipelineStageFlags operator^(PipelineStageFlags a, PipelineStageFlags b) { return static_cast<PipelineStageFlags>(static_cast<std::underlying_type_t<PipelineStageFlags>>(a) ^ static_cast<std::underlying_type_t<PipelineStageFlags>>(b)); }
	constexpr PipelineStageFlags& operator^=(PipelineStageFlags& a, PipelineStageFlags b) { a = a ^ b; return a; }
	constexpr PipelineStageFlags operator<<(PipelineStageFlags a, std::underlying_type_t<PipelineStageFlags> b) { return static_cast<PipelineStageFlags>(static_cast<std::underlying_type_t<PipelineStageFlags>>(a) << b); }
	constexpr PipelineStageFlags operator<<(PipelineStageFlags a, PipelineStageFlags b) { return static_cast<PipelineStageFlags>(static_cast<std::underlying_type_t<PipelineStageFlags>>(a) << static_cast<std::underlying_type_t<PipelineStageFlags>>(b)); }
	constexpr PipelineStageFlags& operator<<=(PipelineStageFlags& a, PipelineStageFlags b) { a = a << b; return a; }
	constexpr PipelineStageFlags operator>>(PipelineStageFlags a, std::underlying_type_t<PipelineStageFlags> b) { return static_cast<PipelineStageFlags>(static_cast<std::underlying_type_t<PipelineStageFlags>>(a) >> b); }
	constexpr PipelineStageFlags operator>>(PipelineStageFlags a, PipelineStageFlags b) { return static_cast<PipelineStageFlags>(static_cast<std::underlying_type_t<PipelineStageFlags>>(a) >> static_cast<std::underlying_type_t<PipelineStageFlags>>(b)); }
	constexpr PipelineStageFlags& operator>>=(PipelineStageFlags& a, PipelineStageFlags b) { a = a >> b; return a; }
	constexpr PipelineStageFlags operator~(PipelineStageFlags a) { return static_cast<PipelineStageFlags>(~static_cast<std::underlying_type_t<PipelineStageFlags>>(a)); }


	constexpr AccessFlags operator|(AccessFlags a, AccessFlags b) { return static_cast<AccessFlags>(static_cast<std::underlying_type_t<AccessFlags>>(a) | static_cast<std::underlying_type_t<AccessFlags>>(b)); }
	constexpr AccessFlags& operator|=(AccessFlags& a, AccessFlags b) { a = a | b; return a; }
	constexpr AccessFlags operator&(AccessFlags a, AccessFlags b) { return static_cast<AccessFlags>(static_cast<std::underlying_type_t<AccessFlags>>(a) & static_cast<std::underlying_type_t<AccessFlags>>(b)); }
	constexpr AccessFlags& operator&=(AccessFlags& a, AccessFlags b) { a = a & b; return a; }
	constexpr AccessFlags operator^(AccessFlags a, AccessFlags b) { return static_cast<AccessFlags>(static_cast<std::underlying_type_t<AccessFlags>>(a) ^ static_cast<std::underlying_type_t<AccessFlags>>(b)); }
	constexpr AccessFlags& operator^=(AccessFlags& a, AccessFlags b) { a = a ^ b; return a; }
	constexpr AccessFlags operator<<(AccessFlags a, std::underlying_type_t<AccessFlags> b) { return static_cast<AccessFlags>(static_cast<std::underlying_type_t<AccessFlags>>(a) << b); }
	constexpr AccessFlags operator<<(AccessFlags a, AccessFlags b) { return static_cast<AccessFlags>(static_cast<std::underlying_type_t<AccessFlags>>(a) << static_cast<std::underlying_type_t<AccessFlags>>(b)); }
	constexpr AccessFlags& operator<<=(AccessFlags& a, AccessFlags b) { a = a << b; return a; }
	constexpr AccessFlags operator>>(AccessFlags a, std::underlying_type_t<AccessFlags> b) { return static_cast<AccessFlags>(static_cast<std::underlying_type_t<AccessFlags>>(a) >> b); }
	constexpr AccessFlags operator>>(AccessFlags a, AccessFlags b) { return static_cast<AccessFlags>(static_cast<std::underlying_type_t<AccessFlags>>(a) >> static_cast<std::underlying_type_t<AccessFlags>>(b)); }
	constexpr AccessFlags& operator>>=(AccessFlags& a, AccessFlags b) { a = a >> b; return a; }
	constexpr AccessFlags operator~(AccessFlags a) { return static_cast<AccessFlags>(~static_cast<std::underlying_type_t<AccessFlags>>(a)); }


	constexpr TextureUsageFlags operator|(TextureUsageFlags a, TextureUsageFlags b) { return static_cast<TextureUsageFlags>(static_cast<std::underlying_type_t<TextureUsageFlags>>(a) | static_cast<std::underlying_type_t<TextureUsageFlags>>(b)); }
	constexpr TextureUsageFlags& operator|=(TextureUsageFlags& a, TextureUsageFlags b) { a = a | b; return a; }
	constexpr TextureUsageFlags operator&(TextureUsageFlags a, TextureUsageFlags b) { return static_cast<TextureUsageFlags>(static_cast<std::underlying_type_t<TextureUsageFlags>>(a) & static_cast<std::underlying_type_t<TextureUsageFlags>>(b)); }
	constexpr TextureUsageFlags& operator&=(TextureUsageFlags& a, TextureUsageFlags b) { a = a & b; return a; }
	constexpr TextureUsageFlags operator^(TextureUsageFlags a, TextureUsageFlags b) { return static_cast<TextureUsageFlags>(static_cast<std::underlying_type_t<TextureUsageFlags>>(a) ^ static_cast<std::underlying_type_t<TextureUsageFlags>>(b)); }
	constexpr TextureUsageFlags& operator^=(TextureUsageFlags& a, TextureUsageFlags b) { a = a ^ b; return a; }
	constexpr TextureUsageFlags operator<<(TextureUsageFlags a, std::underlying_type_t<TextureUsageFlags> b) { return static_cast<TextureUsageFlags>(static_cast<std::underlying_type_t<TextureUsageFlags>>(a) << b); }
	constexpr TextureUsageFlags operator<<(TextureUsageFlags a, TextureUsageFlags b) { return static_cast<TextureUsageFlags>(static_cast<std::underlying_type_t<TextureUsageFlags>>(a) << static_cast<std::underlying_type_t<TextureUsageFlags>>(b)); }
	constexpr TextureUsageFlags& operator<<=(TextureUsageFlags& a, TextureUsageFlags b) { a = a << b; return a; }
	constexpr TextureUsageFlags operator>>(TextureUsageFlags a, std::underlying_type_t<TextureUsageFlags> b) { return static_cast<TextureUsageFlags>(static_cast<std::underlying_type_t<TextureUsageFlags>>(a) >> b); }
	constexpr TextureUsageFlags operator>>(TextureUsageFlags a, TextureUsageFlags b) { return static_cast<TextureUsageFlags>(static_cast<std::underlying_type_t<TextureUsageFlags>>(a) >> static_cast<std::underlying_type_t<TextureUsageFlags>>(b)); }
	constexpr TextureUsageFlags& operator>>=(TextureUsageFlags& a, TextureUsageFlags b) { a = a >> b; return a; }
	constexpr TextureUsageFlags operator~(TextureUsageFlags a) { return static_cast<TextureUsageFlags>(~static_cast<std::underlying_type_t<TextureUsageFlags>>(a)); }


	constexpr ColorComponentFlags operator|(ColorComponentFlags a, ColorComponentFlags b) { return static_cast<ColorComponentFlags>(static_cast<std::underlying_type_t<ColorComponentFlags>>(a) | static_cast<std::underlying_type_t<ColorComponentFlags>>(b)); }
	constexpr ColorComponentFlags& operator|=(ColorComponentFlags& a, ColorComponentFlags b) { a = a | b; return a; }
	constexpr ColorComponentFlags operator&(ColorComponentFlags a, ColorComponentFlags b) { return static_cast<ColorComponentFlags>(static_cast<std::underlying_type_t<ColorComponentFlags>>(a) & static_cast<std::underlying_type_t<ColorComponentFlags>>(b)); }
	constexpr ColorComponentFlags& operator&=(ColorComponentFlags& a, ColorComponentFlags b) { a = a & b; return a; }
	constexpr ColorComponentFlags operator^(ColorComponentFlags a, ColorComponentFlags b) { return static_cast<ColorComponentFlags>(static_cast<std::underlying_type_t<ColorComponentFlags>>(a) ^ static_cast<std::underlying_type_t<ColorComponentFlags>>(b)); }
	constexpr ColorComponentFlags& operator^=(ColorComponentFlags& a, ColorComponentFlags b) { a = a ^ b; return a; }
	constexpr ColorComponentFlags operator<<(ColorComponentFlags a, std::underlying_type_t<ColorComponentFlags> b) { return static_cast<ColorComponentFlags>(static_cast<std::underlying_type_t<ColorComponentFlags>>(a) << b); }
	constexpr ColorComponentFlags operator<<(ColorComponentFlags a, ColorComponentFlags b) { return static_cast<ColorComponentFlags>(static_cast<std::underlying_type_t<ColorComponentFlags>>(a) << static_cast<std::underlying_type_t<ColorComponentFlags>>(b)); }
	constexpr ColorComponentFlags& operator<<=(ColorComponentFlags& a, ColorComponentFlags b) { a = a << b; return a; }
	constexpr ColorComponentFlags operator>>(ColorComponentFlags a, std::underlying_type_t<ColorComponentFlags> b) { return static_cast<ColorComponentFlags>(static_cast<std::underlying_type_t<ColorComponentFlags>>(a) >> b); }
	constexpr ColorComponentFlags operator>>(ColorComponentFlags a, ColorComponentFlags b) { return static_cast<ColorComponentFlags>(static_cast<std::underlying_type_t<ColorComponentFlags>>(a) >> static_cast<std::underlying_type_t<ColorComponentFlags>>(b)); }
	constexpr ColorComponentFlags& operator>>=(ColorComponentFlags& a, ColorComponentFlags b) { a = a >> b; return a; }
	constexpr ColorComponentFlags operator~(ColorComponentFlags a) { return static_cast<ColorComponentFlags>(~static_cast<std::underlying_type_t<ColorComponentFlags>>(a)); }


	inline vg::Result vg::Init(const vg::Config* cfg)
	{
		return static_cast<vg::Result>(vgInit(*reinterpret_cast<const VgConfig**>(&cfg)));
	}
	inline void vg::Shutdown()
	{
		vgShutdown();
	}
	inline vg::Result vg::EnumerateApis(uint32_t* outNumApis, vg::GraphicsApi* outApis)
	{
		return static_cast<vg::Result>(vgEnumerateApis(outNumApis, *reinterpret_cast<VgGraphicsApi**>(&outApis)));
	}
	inline vg::Result vg::EnumerateAdapters(vg::GraphicsApi api, vg::Surface surface, uint32_t* outNumAdapters, vg::Adapter* outAdapters)
	{
		return static_cast<vg::Result>(vgEnumerateAdapters(*reinterpret_cast<VgGraphicsApi*>(&api), *reinterpret_cast<VgSurface*>(&surface), outNumAdapters, *reinterpret_cast<VgAdapter**>(&outAdapters)));
	}
	inline vg::Result vg::GetVulkanObjects(vg::VulkanObjects* outVulkanObjects)
	{
		return static_cast<vg::Result>(vgGetVulkanObjects(*reinterpret_cast<VgVulkanObjects**>(&outVulkanObjects)));
	}
	inline vg::Result vg::CreateSurfaceD3D12(void* hwnd, vg::Surface* outSurface)
	{
		return static_cast<vg::Result>(vgCreateSurfaceD3D12(hwnd, *reinterpret_cast<VgSurface**>(&outSurface)));
	}
	inline vg::Result vg::CreateSurfaceVulkan(VkSurfaceKHR_T* vkSurface, vg::Surface* outSurface)
	{
		return static_cast<vg::Result>(vgCreateSurfaceVulkan(vkSurface, *reinterpret_cast<VgSurface**>(&outSurface)));
	}
	inline void vg::DestroySurfaceVulkan(vg::Surface surface)
	{
		vgDestroySurfaceVulkan(*reinterpret_cast<VgSurface*>(&surface));
	}

	inline vg::Result vg::Adapter::GetProperties(vg::AdapterProperties* outProperties) const
	{
		return static_cast<vg::Result>(vgAdapterGetProperties(_handle, *reinterpret_cast<VgAdapterProperties**>(&outProperties)));
	}
	inline vg::Result vg::Adapter::CreateDevice(vg::Device* outDevice)
	{
		return static_cast<vg::Result>(vgAdapterCreateDevice(_handle, *reinterpret_cast<VgDevice**>(&outDevice)));
	}
	inline void vg::Adapter::DestroyDevice(vg::Device device)
	{
		vgAdapterDestroyDevice(_handle, *reinterpret_cast<VgDevice*>(&device));
	}

	inline vg::Result vg::Device::GetApiObject(void** outObj) const
	{
		return static_cast<vg::Result>(vgDeviceGetApiObject(_handle, outObj));
	}
	inline vg::Result vg::Device::GetAdapter(vg::Adapter* outAdapter) const
	{
		return static_cast<vg::Result>(vgDeviceGetAdapter(_handle, *reinterpret_cast<VgAdapter**>(&outAdapter)));
	}
	inline vg::Result vg::Device::GetGraphicsApi(vg::GraphicsApi* outApi) const
	{
		return static_cast<vg::Result>(vgDeviceGetGraphicsApi(_handle, *reinterpret_cast<VgGraphicsApi**>(&outApi)));
	}
	inline vg::Result vg::Device::GetMemoryStatistics(vg::MemoryStatistics* outMemoryStats) const
	{
		return static_cast<vg::Result>(vgDeviceGetMemoryStatistics(_handle, *reinterpret_cast<VgMemoryStatistics**>(&outMemoryStats)));
	}
	inline void vg::Device::WaitQueueIdle(vg::Queue queue)
	{
		vgDeviceWaitQueueIdle(_handle, *reinterpret_cast<VgQueue*>(&queue));
	}
	inline void vg::Device::WaitIdle()
	{
		vgDeviceWaitIdle(_handle);
	}
	inline vg::Result vg::Device::CreateBuffer(const vg::BufferDesc* desc, vg::Buffer* outBuffer)
	{
		return static_cast<vg::Result>(vgDeviceCreateBuffer(_handle, *reinterpret_cast<const VgBufferDesc**>(&desc), *reinterpret_cast<VgBuffer**>(&outBuffer)));
	}
	inline void vg::Device::DestroyBuffer(vg::Buffer buffer)
	{
		vgDeviceDestroyBuffer(_handle, *reinterpret_cast<VgBuffer*>(&buffer));
	}
	inline vg::Result vg::Device::CreateShaderModule(const void* data, uint64_t size, vg::ShaderModule* outModule)
	{
		return static_cast<vg::Result>(vgDeviceCreateShaderModule(_handle, data, size, *reinterpret_cast<VgShaderModule**>(&outModule)));
	}
	inline void vg::Device::DestroyShaderModule(vg::ShaderModule shaderModule)
	{
		vgDeviceDestroyShaderModule(_handle, *reinterpret_cast<VgShaderModule*>(&shaderModule));
	}
	inline vg::Result vg::Device::CreateGraphicsPipeline(const vg::GraphicsPipelineDesc* desc, vg::Pipeline* outPipeline)
	{
		return static_cast<vg::Result>(vgDeviceCreateGraphicsPipeline(_handle, *reinterpret_cast<const VgGraphicsPipelineDesc**>(&desc), *reinterpret_cast<VgPipeline**>(&outPipeline)));
	}
	inline vg::Result vg::Device::CreateComputePipeline(vg::ShaderModule shaderModule, vg::Pipeline* outPipeline)
	{
		return static_cast<vg::Result>(vgDeviceCreateComputePipeline(_handle, *reinterpret_cast<VgShaderModule*>(&shaderModule), *reinterpret_cast<VgPipeline**>(&outPipeline)));
	}
	inline void vg::Device::DestroyPipeline(vg::Pipeline pipeline)
	{
		vgDeviceDestroyPipeline(_handle, *reinterpret_cast<VgPipeline*>(&pipeline));
	}
	inline vg::Result vg::Device::CreateFence(uint64_t initialValue, vg::Fence* outFence)
	{
		return static_cast<vg::Result>(vgDeviceCreateFence(_handle, initialValue, *reinterpret_cast<VgFence**>(&outFence)));
	}
	inline void vg::Device::DestroyFence(vg::Fence fence)
	{
		vgDeviceDestroyFence(_handle, *reinterpret_cast<VgFence*>(&fence));
	}
	inline vg::Result vg::Device::CreateCommandPool(vg::CommandPoolFlags flags, vg::Queue queue, vg::CommandPool* outPool)
	{
		return static_cast<vg::Result>(vgDeviceCreateCommandPool(_handle, *reinterpret_cast<VgCommandPoolFlags*>(&flags), *reinterpret_cast<VgQueue*>(&queue), *reinterpret_cast<VgCommandPool**>(&outPool)));
	}
	inline void vg::Device::DestroyCommandPool(vg::CommandPool pool)
	{
		vgDeviceDestroyCommandPool(_handle, *reinterpret_cast<VgCommandPool*>(&pool));
	}
	inline vg::Result vg::Device::CreateSampler(const vg::SamplerDesc* desc, vg::Sampler* outSampler)
	{
		return static_cast<vg::Result>(vgDeviceCreateSampler(_handle, *reinterpret_cast<const VgSamplerDesc**>(&desc), *reinterpret_cast<VgSampler**>(&outSampler)));
	}
	inline void vg::Device::DestroySampler(vg::Sampler sampler)
	{
		vgDeviceDestroySampler(_handle, *reinterpret_cast<VgSampler*>(&sampler));
	}
	inline vg::Result vg::Device::CreateTexture(const vg::TextureDesc* desc, vg::Texture* outTexture)
	{
		return static_cast<vg::Result>(vgDeviceCreateTexture(_handle, *reinterpret_cast<const VgTextureDesc**>(&desc), *reinterpret_cast<VgTexture**>(&outTexture)));
	}
	inline void vg::Device::DestroyTexture(vg::Texture texture)
	{
		vgDeviceDestroyTexture(_handle, *reinterpret_cast<VgTexture*>(&texture));
	}
	inline void vg::Device::SubmitCommandLists(uint32_t numSubmits, vg::SubmitInfo* submits)
	{
		vgDeviceSubmitCommandLists(_handle, numSubmits, *reinterpret_cast<VgSubmitInfo**>(&submits));
	}
	inline vg::Result vg::Device::SignalFence(vg::Fence fence, uint64_t value)
	{
		return static_cast<vg::Result>(vgDeviceSignalFence(_handle, *reinterpret_cast<VgFence*>(&fence), value));
	}
	inline void vg::Device::WaitFence(vg::Fence fence, uint64_t value)
	{
		vgDeviceWaitFence(_handle, *reinterpret_cast<VgFence*>(&fence), value);
	}
	inline vg::Result vg::Device::GetFenceValue(vg::Fence fence, uint64_t* outValue) const
	{
		return static_cast<vg::Result>(vgDeviceGetFenceValue(_handle, *reinterpret_cast<VgFence*>(&fence), outValue));
	}
	inline vg::Result vg::Device::CreateSwapChain(const vg::SwapChainDesc* desc, vg::SwapChain* outSwapChain)
	{
		return static_cast<vg::Result>(vgDeviceCreateSwapChain(_handle, *reinterpret_cast<const VgSwapChainDesc**>(&desc), *reinterpret_cast<VgSwapChain**>(&outSwapChain)));
	}
	inline void vg::Device::DestroySwapChain(vg::SwapChain swapChain)
	{
		vgDeviceDestroySwapChain(_handle, *reinterpret_cast<VgSwapChain*>(&swapChain));
	}
	inline vg::Result vg::Device::GetSamplerIndex(vg::Sampler sampler, uint32_t* outIndex) const
	{
		return static_cast<vg::Result>(vgDeviceGetSamplerIndex(_handle, *reinterpret_cast<VgSampler*>(&sampler), outIndex));
	}

	inline vg::Result vg::CommandPool::GetApiObject(void** outObj) const
	{
		return static_cast<vg::Result>(vgCommandPoolGetApiObject(_handle, outObj));
	}
	inline void vg::CommandPool::SetName(const char* name)
	{
		vgCommandPoolSetName(_handle, name);
	}
	inline vg::Result vg::CommandPool::GetDevice(vg::Device* outDevice) const
	{
		return static_cast<vg::Result>(vgCommandPoolGetDevice(_handle, *reinterpret_cast<VgDevice**>(&outDevice)));
	}
	inline vg::Result vg::CommandPool::GetQueue(vg::Queue* outQueue) const
	{
		return static_cast<vg::Result>(vgCommandPoolGetQueue(_handle, *reinterpret_cast<VgQueue**>(&outQueue)));
	}
	inline vg::Result vg::CommandPool::AllocateCommandList(vg::CommandList* outCmd)
	{
		return static_cast<vg::Result>(vgCommandPoolAllocateCommandList(_handle, *reinterpret_cast<VgCommandList**>(&outCmd)));
	}
	inline void vg::CommandPool::FreeCommandList(vg::CommandList cmd)
	{
		vgCommandPoolFreeCommandList(_handle, *reinterpret_cast<VgCommandList*>(&cmd));
	}
	inline void vg::CommandPool::Reset()
	{
		vgCommandPoolReset(_handle);
	}

	inline vg::Result vg::CommandList::GetApiObject(void** outObj) const
	{
		return static_cast<vg::Result>(vgCommandListGetApiObject(_handle, outObj));
	}
	inline void vg::CommandList::SetName(const char* name)
	{
		vgCommandListSetName(_handle, name);
	}
	inline vg::Result vg::CommandList::GetDevice(vg::Device* outDevice) const
	{
		return static_cast<vg::Result>(vgCommandListGetDevice(_handle, *reinterpret_cast<VgDevice**>(&outDevice)));
	}
	inline vg::Result vg::CommandList::GetCommandPool(vg::CommandPool* outPool) const
	{
		return static_cast<vg::Result>(vgCommandListGetCommandPool(_handle, *reinterpret_cast<VgCommandPool**>(&outPool)));
	}
	inline vg::Result vg::CommandList::GetQueue(vg::Queue* outQueue) const
	{
		return static_cast<vg::Result>(vgCommandListGetQueue(_handle, *reinterpret_cast<VgQueue**>(&outQueue)));
	}
	inline void vg::CommandList::RestoreDescriptorState()
	{
		vgCommandListRestoreDescriptorState(_handle);
	}
	inline void vg::CommandList::Begin()
	{
		vgCmdBegin(_handle);
	}
	inline void vg::CommandList::End()
	{
		vgCmdEnd(_handle);
	}
	inline void vg::CommandList::SetVertexBuffers(uint32_t startSlot, uint32_t numBuffers, const vg::VertexBufferView* buffers)
	{
		vgCmdSetVertexBuffers(_handle, startSlot, numBuffers, *reinterpret_cast<const VgVertexBufferView**>(&buffers));
	}
	inline void vg::CommandList::SetIndexBuffer(vg::IndexType indexType, uint64_t offset, vg::Buffer indexBuffer)
	{
		vgCmdSetIndexBuffer(_handle, *reinterpret_cast<VgIndexType*>(&indexType), offset, *reinterpret_cast<VgBuffer*>(&indexBuffer));
	}
	inline void vg::CommandList::SetRootConstants(vg::PipelineType pipelineType, uint32_t offsetIn32bitValues, uint32_t num32bitValues, const void* data)
	{
		vgCmdSetRootConstants(_handle, *reinterpret_cast<VgPipelineType*>(&pipelineType), offsetIn32bitValues, num32bitValues, data);
	}
	inline void vg::CommandList::SetPipeline(vg::Pipeline pipeline)
	{
		vgCmdSetPipeline(_handle, *reinterpret_cast<VgPipeline*>(&pipeline));
	}
	inline void vg::CommandList::Barrier(const vg::DependencyInfo* dependencyInfo)
	{
		vgCmdBarrier(_handle, *reinterpret_cast<const VgDependencyInfo**>(&dependencyInfo));
	}
	inline vg::Result vg::CommandList::BeginRendering(const vg::RenderingInfo* info)
	{
		return static_cast<vg::Result>(vgCmdBeginRendering(_handle, *reinterpret_cast<const VgRenderingInfo**>(&info)));
	}
	inline void vg::CommandList::EndRendering()
	{
		vgCmdEndRendering(_handle);
	}
	inline void vg::CommandList::SetViewport(uint32_t firstViewport, uint32_t numViewports, vg::Viewport* viewports)
	{
		vgCmdSetViewport(_handle, firstViewport, numViewports, *reinterpret_cast<VgViewport**>(&viewports));
	}
	inline void vg::CommandList::SetScissor(uint32_t firstScissor, uint32_t numScissors, vg::Scissor* scissors)
	{
		vgCmdSetScissor(_handle, firstScissor, numScissors, *reinterpret_cast<VgScissor**>(&scissors));
	}
	inline void vg::CommandList::Draw(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance)
	{
		vgCmdDraw(_handle, vertexCount, instanceCount, firstVertex, firstInstance);
	}
	inline void vg::CommandList::DrawIndexed(uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, uint32_t vertexOffset, uint32_t firstInstance)
	{
		vgCmdDrawIndexed(_handle, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
	}
	inline void vg::CommandList::Dispatch(uint32_t groupsX, uint32_t groupsY, uint32_t groupsZ)
	{
		vgCmdDispatch(_handle, groupsX, groupsY, groupsZ);
	}
	inline void vg::CommandList::DrawIndirect(vg::Buffer buffer, uint64_t offset, uint32_t drawCount, uint32_t stride)
	{
		vgCmdDrawIndirect(_handle, *reinterpret_cast<VgBuffer*>(&buffer), offset, drawCount, stride);
	}
	inline void vg::CommandList::DrawIndirectCount(vg::Buffer buffer, uint64_t offset, vg::Buffer countBuffer, uint64_t countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
	{
		vgCmdDrawIndirectCount(_handle, *reinterpret_cast<VgBuffer*>(&buffer), offset, *reinterpret_cast<VgBuffer*>(&countBuffer), countBufferOffset, maxDrawCount, stride);
	}
	inline void vg::CommandList::DrawIndexedIndirect(vg::Buffer buffer, uint64_t offset, uint32_t drawCount, uint32_t stride)
	{
		vgCmdDrawIndexedIndirect(_handle, *reinterpret_cast<VgBuffer*>(&buffer), offset, drawCount, stride);
	}
	inline void vg::CommandList::DrawIndexedIndirectCount(vg::Buffer buffer, uint64_t offset, vg::Buffer countBuffer, uint64_t countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
	{
		vgCmdDrawIndexedIndirectCount(_handle, *reinterpret_cast<VgBuffer*>(&buffer), offset, *reinterpret_cast<VgBuffer*>(&countBuffer), countBufferOffset, maxDrawCount, stride);
	}
	inline void vg::CommandList::DispatchIndirect(vg::Buffer buffer, uint64_t offset)
	{
		vgCmdDispatchIndirect(_handle, *reinterpret_cast<VgBuffer*>(&buffer), offset);
	}
	inline void vg::CommandList::CopyBufferToBuffer(vg::Buffer dst, uint64_t dstOffset, vg::Buffer src, uint64_t srcOffset, uint64_t size)
	{
		vgCmdCopyBufferToBuffer(_handle, *reinterpret_cast<VgBuffer*>(&dst), dstOffset, *reinterpret_cast<VgBuffer*>(&src), srcOffset, size);
	}
	inline void vg::CommandList::CopyBufferToTexture(vg::Texture dst, const vg::Region* dstRegion, vg::Buffer src, uint64_t srcOffset)
	{
		vgCmdCopyBufferToTexture(_handle, *reinterpret_cast<VgTexture*>(&dst), *reinterpret_cast<const VgRegion**>(&dstRegion), *reinterpret_cast<VgBuffer*>(&src), srcOffset);
	}
	inline void vg::CommandList::CopyTextureToBuffer(vg::Buffer dst, uint64_t dstOffset, vg::Texture src, const vg::Region* srcRegion)
	{
		vgCmdCopyTextureToBuffer(_handle, *reinterpret_cast<VgBuffer*>(&dst), dstOffset, *reinterpret_cast<VgTexture*>(&src), *reinterpret_cast<const VgRegion**>(&srcRegion));
	}
	inline void vg::CommandList::CopyTextureToTexture(vg::Texture dst, const vg::Region* dstRegion, vg::Texture src, const vg::Region* srcRegion)
	{
		vgCmdCopyTextureToTexture(_handle, *reinterpret_cast<VgTexture*>(&dst), *reinterpret_cast<const VgRegion**>(&dstRegion), *reinterpret_cast<VgTexture*>(&src), *reinterpret_cast<const VgRegion**>(&srcRegion));
	}
	inline void vg::CommandList::BeginMarker(const char* name, std::array<float, 3> color)
	{
		vgCmdBeginMarker(_handle, name, color.data());
	}
	inline void vg::CommandList::EndMarker()
	{
		vgCmdEndMarker(_handle);
	}

	inline vg::Result vg::Buffer::GetApiObject(void** outObj) const
	{
		return static_cast<vg::Result>(vgBufferGetApiObject(_handle, outObj));
	}
	inline void vg::Buffer::SetName(const char* name)
	{
		vgBufferSetName(_handle, name);
	}
	inline vg::Result vg::Buffer::GetDevice(vg::Device* outDevice) const
	{
		return static_cast<vg::Result>(vgBufferGetDevice(_handle, *reinterpret_cast<VgDevice**>(&outDevice)));
	}
	inline vg::Result vg::Buffer::GetDesc(vg::BufferDesc* outDesc) const
	{
		return static_cast<vg::Result>(vgBufferGetDesc(_handle, *reinterpret_cast<VgBufferDesc**>(&outDesc)));
	}
	inline vg::Result vg::Buffer::CreateView(const vg::BufferViewDesc* desc, vg::View* outDescriptor)
	{
		return static_cast<vg::Result>(vgBufferCreateView(_handle, *reinterpret_cast<const VgBufferViewDesc**>(&desc), *reinterpret_cast<VgView**>(&outDescriptor)));
	}
	inline void vg::Buffer::DestroyViews()
	{
		vgBufferDestroyViews(_handle);
	}
	inline vg::Result vg::Buffer::Map(void** outData)
	{
		return static_cast<vg::Result>(vgBufferMap(_handle, outData));
	}
	inline void vg::Buffer::Unmap()
	{
		vgBufferUnmap(_handle);
	}

	inline vg::Result vg::Pipeline::GetApiObject(void** outObj) const
	{
		return static_cast<vg::Result>(vgPipelineGetApiObject(_handle, outObj));
	}
	inline void vg::Pipeline::SetName(const char* name)
	{
		vgPipelineSetName(_handle, name);
	}
	inline vg::Result vg::Pipeline::GetDevice(vg::Device* outDevice) const
	{
		return static_cast<vg::Result>(vgPipelineGetDevice(_handle, *reinterpret_cast<VgDevice**>(&outDevice)));
	}
	inline vg::Result vg::Pipeline::GetType(vg::PipelineType* outType) const
	{
		return static_cast<vg::Result>(vgPipelineGetType(_handle, *reinterpret_cast<VgPipelineType**>(&outType)));
	}

	inline vg::Result vg::Texture::GetApiObject(void** outObj) const
	{
		return static_cast<vg::Result>(vgTextureGetApiObject(_handle, outObj));
	}
	inline void vg::Texture::SetName(const char* name)
	{
		vgTextureSetName(_handle, name);
	}
	inline vg::Result vg::Texture::GetDevice(vg::Device* outDevice) const
	{
		return static_cast<vg::Result>(vgTextureGetDevice(_handle, *reinterpret_cast<VgDevice**>(&outDevice)));
	}
	inline vg::Result vg::Texture::GetDesc(vg::TextureDesc* outDesc) const
	{
		return static_cast<vg::Result>(vgTextureGetDesc(_handle, *reinterpret_cast<VgTextureDesc**>(&outDesc)));
	}
	inline vg::Result vg::Texture::CreateAttachmentView(const vg::AttachmentViewDesc* desc, vg::AttachmentView* outDescriptor)
	{
		return static_cast<vg::Result>(vgTextureCreateAttachmentView(_handle, *reinterpret_cast<const VgAttachmentViewDesc**>(&desc), *reinterpret_cast<VgAttachmentView**>(&outDescriptor)));
	}
	inline vg::Result vg::Texture::CreateView(const vg::TextureViewDesc* desc, vg::View* outDescriptor)
	{
		return static_cast<vg::Result>(vgTextureCreateView(_handle, *reinterpret_cast<const VgTextureViewDesc**>(&desc), *reinterpret_cast<VgView**>(&outDescriptor)));
	}
	inline void vg::Texture::DestroyViews()
	{
		vgTextureDestroyViews(_handle);
	}

	inline vg::Result vg::SwapChain::GetApiObject(void** outObj) const
	{
		return static_cast<vg::Result>(vgSwapChainGetApiObject(_handle, outObj));
	}
	inline vg::Result vg::SwapChain::GetDevice(vg::Device* outDevice) const
	{
		return static_cast<vg::Result>(vgSwapChainGetDevice(_handle, *reinterpret_cast<VgDevice**>(&outDevice)));
	}
	inline vg::Result vg::SwapChain::GetDesc(vg::SwapChainDesc* outDesc) const
	{
		return static_cast<vg::Result>(vgSwapChainGetDesc(_handle, *reinterpret_cast<VgSwapChainDesc**>(&outDesc)));
	}
	inline vg::Result vg::SwapChain::AcquireNextImage(uint32_t* outImageIndex)
	{
		return static_cast<vg::Result>(vgSwapChainAcquireNextImage(_handle, outImageIndex));
	}
	inline vg::Result vg::SwapChain::GetBackBuffer(uint32_t index, vg::Texture* outBackBuffer) const
	{
		return static_cast<vg::Result>(vgSwapChainGetBackBuffer(_handle, index, *reinterpret_cast<VgTexture**>(&outBackBuffer)));
	}
	inline vg::Result vg::SwapChain::Present(uint32_t numWaitFences, vg::FenceOperation* waitFences)
	{
		return static_cast<vg::Result>(vgSwapChainPresent(_handle, numWaitFences, *reinterpret_cast<VgFenceOperation**>(&waitFences)));
	}
	static_assert(sizeof(Allocator) == sizeof(VgAllocator));
	static_assert(sizeof(Config) == sizeof(VgConfig));
	static_assert(sizeof(AdapterProperties) == sizeof(VgAdapterProperties));
	static_assert(sizeof(BufferDesc) == sizeof(VgBufferDesc));
	static_assert(sizeof(VertexBufferView) == sizeof(VgVertexBufferView));
	static_assert(sizeof(BufferViewDesc) == sizeof(VgBufferViewDesc));
	static_assert(sizeof(FenceOperation) == sizeof(VgFenceOperation));
	static_assert(sizeof(SubmitInfo) == sizeof(VgSubmitInfo));
	static_assert(sizeof(TextureSubresourceRange) == sizeof(VgTextureSubresourceRange));
	static_assert(sizeof(MemoryBarrier) == sizeof(VgMemoryBarrier));
	static_assert(sizeof(BufferBarrier) == sizeof(VgBufferBarrier));
	static_assert(sizeof(TextureBarrier) == sizeof(VgTextureBarrier));
	static_assert(sizeof(DependencyInfo) == sizeof(VgDependencyInfo));
	static_assert(sizeof(SamplerDesc) == sizeof(VgSamplerDesc));
	static_assert(sizeof(TextureDesc) == sizeof(VgTextureDesc));
	static_assert(sizeof(AttachmentViewDesc) == sizeof(VgAttachmentViewDesc));
	static_assert(sizeof(AttachmentInfo) == sizeof(VgAttachmentInfo));
	static_assert(sizeof(RenderingInfo) == sizeof(VgRenderingInfo));
	static_assert(sizeof(ComponentSwizzle) == sizeof(VgComponentSwizzle));
	static_assert(sizeof(TextureViewDesc) == sizeof(VgTextureViewDesc));
	static_assert(sizeof(Offset) == sizeof(VgOffset));
	static_assert(sizeof(Region) == sizeof(VgRegion));
	static_assert(sizeof(SwapChainDesc) == sizeof(VgSwapChainDesc));
	static_assert(sizeof(VertexAttribute) == sizeof(VgVertexAttribute));
	static_assert(sizeof(FixedFunctionState) == sizeof(VgFixedFunctionState));
	static_assert(sizeof(MeshShaderState) == sizeof(VgMeshShaderState));
	static_assert(sizeof(RasterizationState) == sizeof(VgRasterizationState));
	static_assert(sizeof(StencilState) == sizeof(VgStencilState));
	static_assert(sizeof(DepthStencilState) == sizeof(VgDepthStencilState));
	static_assert(sizeof(MultisamplingState) == sizeof(VgMultisamplingState));
	static_assert(sizeof(AttachmentBlendState) == sizeof(VgAttachmentBlendState));
	static_assert(sizeof(BlendState) == sizeof(VgBlendState));
	static_assert(sizeof(GraphicsPipelineDesc) == sizeof(VgGraphicsPipelineDesc));
	static_assert(sizeof(Viewport) == sizeof(VgViewport));
	static_assert(sizeof(Scissor) == sizeof(VgScissor));
	static_assert(sizeof(MemoryStatistics) == sizeof(VgMemoryStatistics));
	static_assert(sizeof(DrawIndirectCommand) == sizeof(VgDrawIndirectCommand));
	static_assert(sizeof(DrawIndexedIndirectCommand) == sizeof(VgDrawIndexedIndirectCommand));
	static_assert(sizeof(DispatchIndirectCommand) == sizeof(VgDispatchIndirectCommand));
	static_assert(sizeof(VulkanObjects) == sizeof(VgVulkanObjects));

}
