import sys
import os
import io
import re
from cxxheaderparser.types import DecoratedType, AnonymousName
from cxxheaderparser.simple import parse_string
from pcpp import Preprocessor

def preprocess_header(header_path):
    """Preprocess the header file using pcpp."""
    pp = Preprocessor()
    with open(header_path, "r", encoding="utf-8") as f:
        pp.parse(f.read())
    
    output = io.StringIO()

    pp.write(output)
    return output.getvalue()

def transform_name(name: str):
    return name.removeprefix("Vg").removeprefix("vg")

def transform_name_with_ns(name: str, ns: str):
    if name.startswith(":arr"):
        parts = name.split("!")
        name = parts[1] + f"[{parts[0].removeprefix(":arr")}]"

    add_const = name.startswith("const")
    if add_const:
        name = name.removeprefix("const ")

    add_ns = name.startswith("Vg") or name.startswith("vg")
    return ("const " if add_const else "") + (ns if add_ns else "") + name.removeprefix("Vg").removeprefix("vg")

def camel_case_split(str) -> str:
    return re.findall(r'[A-Z](?:[a-z]+|[A-Z]*(?=[A-Z]|$))', str)

def transform_enum_name(name: str):
    return "_".join([x.upper() for x in camel_case_split(name)]).removesuffix("_FLAGS") + "_"

def transform_enum_value(enum_name: str, value: str):
    val = "".join(x.lower().capitalize() for x in value.removeprefix(enum_name).removeprefix("VG_").split("_"))
    return ("e" if val[0].isnumeric() else "") + val

def make_type_string(type: DecoratedType, skip_array = False, is_param = False):
    if hasattr(type, "ptr_to"):
        return make_type_string(type.ptr_to) + "*"
    if hasattr(type, "array_of"):
        if not is_param:
            return make_type_string(type.array_of) + f"[{type.size.tokens[0].value}]" if not skip_array else make_type_string(type.array_of)
        else:
            # f":arr{type.size.tokens[0].value}!" + 
            return f"std::array<{make_type_string(type.array_of)}, {type.size.tokens[0].value}>"
    return ("const " if type.const else "") + "".join([(x.name if not isinstance(x, AnonymousName) else "[anonymous]") for x in type.typename.segments])

def transform_field(name: str):
    res = "".join([x.lower().capitalize() for x in name.split("_")])
    return res[0].lower() + res[1:]





includes = [
    "cstddef",
    "cstring",
    "compare",
    "array"
]

types = [
    "Adapter",
    "Device",
    "CommandPool",
    "CommandList",
    "Cmd",
    "Buffer",
    "Pipeline",
    "Texture",
    "SwapChain"
]


additional_structs = """
\tstruct ClearColor
\t{
\t\tfloat color[4];
\t
\t\tClearColor(float r, float g, float b, float a)
\t\t{
\t\t    color[0] = r;
\t\t    color[1] = g;
\t\t    color[2] = b;
\t\t    color[3] = a;
\t\t}
\t};
\t
\tstruct ClearDepth
\t{
\t\tfloat depth;
\t
\t\texplicit ClearDepth(float depth) : depth(depth) {}
\t};
\t
\tstruct ClearStencil
\t{
\t\tuint32_t stencil;
\t
\t\texplicit ClearStencil(uint32_t stencil) : stencil(stencil) {}
\t
\t};
\t
\tstruct ClearValue
\t{
\t\tusing NativeType = VgClearValue;
\t\tVgClearValue clear;
\t
\t\tClearValue() = default;
\t\tClearValue(const VgClearValue& clear_) : clear(clear_) {}
\t\tClearValue(const ClearColor& color)
\t\t{
\t\t\tmemcpy(clear.color, color.color, sizeof(float) * 4);
\t\t}
\t\tClearValue(ClearDepth depth)
\t\t{
\t\t\tclear.depth = depth.depth;
\t\t}
\t\tClearValue(ClearStencil stencil)
\t\t{
\t\t\tclear.stencil = stencil.stencil;
\t\t}
\t};

"""


def parse_header(header_path):
    f = open('../include/varyag.hpp', "w")
    f.write("// Generated by Varyag generate-hpp tool\n\n")
    f.write("#pragma once\n")
    f.write("\n")
    f.write("#include \"varyag.h\"\n")
    for inc in includes:
        f.write(f"#include <{inc}>\n")
    f.write("\n")
    f.write("namespace vg\n")
    f.write("{\n")

    ns = "vg::"
    visual_junk = []

    try:
        preprocessed_code = preprocess_header(header_path)
        while True:
            index = preprocessed_code.find('#line')
            if index == -1:
                break
            end = preprocessed_code.find('\n', index)
            preprocessed_code = preprocessed_code[:index] + preprocessed_code[end + 1:]

        parsed = parse_string(preprocessed_code, filename=header_path)
        
        f.write("\tusing ShaderModule = VgShaderModule;\n")
        f.write("\tusing Fence = VgFence;\n")
        f.write("\tusing Sampler = VgSampler;\n")
        f.write("\tusing Surface = VgSurface;\n")
        f.write("\tusing View = VgView;\n")
        f.write("\tusing AttachmentView = VgAttachmentView;\n")
        f.write("\n")

        for t in types:
            f.write(f"\tclass {t};\n")
        f.write("\n")

        for var in parsed.namespace.variables:
            name = var.name.segments[0].name
            f.write(f"\tstatic constexpr {make_type_string(var.type).removeprefix("const ")} {transform_field(name.removeprefix("vg_"))} = {name};\n")
        f.write("\n")

        for enum in parsed.namespace.enums:
            enum_name = enum.typename.segments[0].name
            cpp_name = transform_name(enum_name)
            f.write(f"\tenum class {cpp_name} : uint64_t\n")
            f.write("\t{\n")

            prefix = transform_enum_name(enum_name)
            members = [(transform_enum_value(prefix, x.name), x.name) for x in enum.values]
            max_length = max([len(x[0]) for x in members])

            for name, value in members:
                f.write(f"\t\t{name}{" " * (max_length - len(name))} = {value},\n")

            f.write("\t};\n\n")

            if enum_name.endswith("Flags"):
                visual_junk.append("\n\tconstexpr $e operator|($e a, $e b) { return static_cast<$e>(static_cast<std::underlying_type_t<$e>>(a) | static_cast<std::underlying_type_t<$e>>(b)); }\n".replace("$e", cpp_name))
                visual_junk.append("\tconstexpr $e& operator|=($e& a, $e b) { a = a | b; return a; }\n".replace("$e", cpp_name))
                visual_junk.append("\tconstexpr $e operator&($e a, $e b) { return static_cast<$e>(static_cast<std::underlying_type_t<$e>>(a) & static_cast<std::underlying_type_t<$e>>(b)); }\n".replace("$e", cpp_name))
                visual_junk.append("\tconstexpr $e& operator&=($e& a, $e b) { a = a & b; return a; }\n".replace("$e", cpp_name))
                visual_junk.append("\tconstexpr $e operator^($e a, $e b) { return static_cast<$e>(static_cast<std::underlying_type_t<$e>>(a) ^ static_cast<std::underlying_type_t<$e>>(b)); }\n".replace("$e", cpp_name))
                visual_junk.append("\tconstexpr $e& operator^=($e& a, $e b) { a = a ^ b; return a; }\n".replace("$e", cpp_name))
                visual_junk.append("\tconstexpr $e operator<<($e a, std::underlying_type_t<$e> b) { return static_cast<$e>(static_cast<std::underlying_type_t<$e>>(a) << b); }\n".replace("$e", cpp_name))
                visual_junk.append("\tconstexpr $e operator<<($e a, $e b) { return static_cast<$e>(static_cast<std::underlying_type_t<$e>>(a) << static_cast<std::underlying_type_t<$e>>(b)); }\n".replace("$e", cpp_name))
                visual_junk.append("\tconstexpr $e& operator<<=($e& a, $e b) { a = a << b; return a; }\n".replace("$e", cpp_name))
                visual_junk.append("\tconstexpr $e operator>>($e a, std::underlying_type_t<$e> b) { return static_cast<$e>(static_cast<std::underlying_type_t<$e>>(a) >> b); }\n".replace("$e", cpp_name))
                visual_junk.append("\tconstexpr $e operator>>($e a, $e b) { return static_cast<$e>(static_cast<std::underlying_type_t<$e>>(a) >> static_cast<std::underlying_type_t<$e>>(b)); }\n".replace("$e", cpp_name))
                visual_junk.append("\tconstexpr $e& operator>>=($e& a, $e b) { a = a >> b; return a; }\n".replace("$e", cpp_name))
                visual_junk.append("\tconstexpr $e operator~($e a) { return static_cast<$e>(~static_cast<std::underlying_type_t<$e>>(a)); }\n\n".replace("$e", cpp_name))

            #visual_junk.append(f"\tconstexpr operator {enum_name}({cpp_name} value) {{ return static_cast<{enum_name}>(value); }}\n")
            #visual_junk.append(f"\tconstexpr operator {cpp_name}({enum_name} value) {{ return static_cast<{cpp_name}>(value); }}\n")
        visual_junk.append("\n")

        for typedef in parsed.namespace.typedefs:
            if typedef.name.endswith("PFN"):
                f.write(f"\tusing {typedef.name[2:]} = {typedef.name};\n")
        f.write("\n")

        for struct in parsed.namespace.classes:
            c_name = struct.class_decl.typename.segments[0].name
            name = transform_name(c_name)
            f.write(f"\tstruct {name};\n")
        f.write("\n")

        method_map = {}
        for t in types:
            method_map[t] = []

        free_functions = []
        for func in parsed.namespace.functions:
            params = ", ".join(f"{make_type_string(p.type)} {p.name}" for p in func.parameters)
            return_type = make_type_string(func.return_type)

            name = func.name.segments[0].name.removeprefix("vg")
            found_type = False
            for t in types:
                if name.startswith(t):
                    name = name[len(t):]
                    t = t.replace("Cmd", "CommandList")
                    method_map[t].append((name, func))
                    found_type = True
                    break
            
            if not found_type:
                free_functions.append((name, func))
    
        max_return_type_length = max([len(transform_name_with_ns(make_type_string(x[1].return_type), ns)) for x in free_functions])
        max_func_name_length = max([len(x[0]) for x in free_functions])
        max_length = max_return_type_length + max_func_name_length
        for name, func in free_functions:
            return_type = transform_name_with_ns(make_type_string(func.return_type), ns)
            beautiful_params = f",\n\t{(" " * (max_length + 2))}".join(f"{transform_name_with_ns(make_type_string(p.type, False, True), ns)} {transform_field(p.name)}" for p in func.parameters)
            f.write(f"\t{return_type}{(" " * (max_return_type_length - len(return_type)))} {name}{(" " * (max_func_name_length - len(name)))}({beautiful_params});\n\n")

            params = ", ".join(f"{transform_name_with_ns(make_type_string(p.type, False, True), ns)} {transform_field(p.name)}" for p in func.parameters)
            visual_junk.append(f"\tinline {return_type} {ns}{name}({params})\n\t{{\n\t\t")
            if return_type != "void":
                visual_junk.append(f"return static_cast<{return_type}>(")
            
            convert_type = lambda name, type: f"*reinterpret_cast<{make_type_string(type)}*>(&{name})" if make_type_string(type, False, True).removeprefix("const ").startswith("Vg") else (f"{name}.data()" if ("std::array" in make_type_string(type, False, True)) else name)

            passthrough = [convert_type(transform_field(x.name), x.type) for x in func.parameters]

            visual_junk.append(f"{func.name.segments[0].name}({", ".join(passthrough)})")
            if return_type != "void":
                visual_junk.append(")")
                pass
            visual_junk.append(";\n")
            visual_junk.append("\t}\n")

        for obj, methods in method_map.items():
            if len(methods) == 0:
                continue

            f.write(f"\tclass {obj}\n\t{{\n\tpublic:\n\t\tusing NativeType = Vg{obj};\n")

            f.write(f"\n\t\t{obj}() : _handle{{ nullptr }} {{}}\n")
            f.write(f"\t\t{obj}(std::nullptr_t) : _handle{{ nullptr }} {{}}\n")
            f.write(f"\t\t{obj}(Vg{obj} handle) : _handle{{ handle }} {{}}\n")
            f.write(f"\t\t{obj}(const {ns}{obj}&) = default;\n")
            f.write(f"\t\t{obj}({ns}{obj}&&) = default;\n")
            f.write(f"\t\t~{obj}() = default;\n")
            f.write(f"\n\t\tconstexpr {obj}& operator=(const {ns}{obj}&) noexcept = default;\n")
            f.write(f"\t\tinline {obj}& operator=(const Vg{obj}& other) noexcept\n\t\t{{\n\t\t\t*this = *reinterpret_cast<const {ns}{obj}*>(&other);\n\t\t\treturn *this;\n\t\t}}\n")
            f.write(f"\t\tconstexpr operator Vg{obj}&() noexcept {{ return _handle; }}\n")
            f.write(f"\t\tconstexpr operator const Vg{obj}&() const noexcept {{ return _handle; }}\n")
            f.write(f"\t\tconstexpr operator bool() const noexcept {{ return _handle; }}\n")
            f.write(f"\t\tauto operator<=>({obj} const&) const = default;\n\n")

            max_return_type_length = max([len(transform_name_with_ns(make_type_string(x[1].return_type), ns)) for x in methods])
            max_func_name_length = max([len(x[0]) for x in methods])
            max_length = max_return_type_length + max_func_name_length

            visual_junk.append("\n")
            for name, func in methods:
                return_type = transform_name_with_ns(make_type_string(func.return_type), ns)
                beautiful_params = f",\n\t\t{(" " * (max_length + 2))}".join(f"{transform_name_with_ns(make_type_string(p.type, False, True), ns)} {transform_field(p.name)}" for p in func.parameters[1:])
                f.write(f"\t\t{return_type}{(" " * (max_return_type_length - len(return_type)))} {name}{(" " * (max_func_name_length - len(name)))}({beautiful_params}){(" const" if "Get" in name else "")};\n\n")
                
                params = ", ".join(f"{transform_name_with_ns(make_type_string(p.type, False, True), ns)} {transform_field(p.name)}" for p in func.parameters[1:])
                visual_junk.append(f"\tinline {return_type} {ns}{obj}::{name}({params}){(" const" if "Get" in name else "")}\n\t{{\n\t\t")
                if return_type != "void":
                    visual_junk.append(f"return static_cast<{return_type}>(")
                
                convert_type = lambda name, type: f"*reinterpret_cast<{make_type_string(type)}*>(&{name})" if make_type_string(type, False, True).removeprefix("const ").startswith("Vg") else (f"{name}.data()" if ("std::array" in make_type_string(type, False, True)) else name)

                passthrough = ["_handle"]
                passthrough.extend([convert_type(transform_field(x.name), x.type) for x in func.parameters[1:]])

                visual_junk.append(f"{func.name.segments[0].name}({", ".join(passthrough)})")
                if return_type != "void":
                    visual_junk.append(")")
                    pass
                visual_junk.append(";\n")
                visual_junk.append("\t}\n")

            f.write("\tprivate:\n")
            f.write(f"\t\tVg{obj} _handle;\n")
            f.write("\t};\n\n")

        f.write(additional_structs)

        for struct in parsed.namespace.classes:
            c_name = struct.class_decl.typename.segments[0].name
            name = transform_name(c_name)
            if name == "ClearValue":
                print("  ClearValue")
                continue
            
            f.write(f"\tstruct {name}\n")
            f.write("\t{\n")

            f.write(f"\t\tusing NativeType = {c_name};\n\n")
            constructor_fields = []
            constructor_init = []

            max_length = max([len(transform_name(make_type_string(x.type, skip_array=True))) for x in struct.fields])

            field_index = 0
            for field in struct.fields:
                if field.name is None:
                    f.write(str(field.value) + "\n")
                    continue

                field_type = transform_name(make_type_string(field.type, skip_array=True))
                field_name = transform_field(field.name)
                f.write(f"\t\t{field_type} {field_name}{("" if not hasattr(field.type, "array_of") else f"[{field.type.size.tokens[0].value}]")};\n")
                
                constructor_fields.append(f"{field_type}{(" " * (max_length - len(field_type)))} {field_name}_{("= {}" if field_index > 0 else "")}")
                constructor_init.append(f"{field_name}{{ {field_name}_ }}")
                field_index += 1
            
            f.write(f"\n\t\t{name}() = default;\n")
            f.write(f"\n\t\t{name}(\n\t\t\t{(",\n\t\t\t".join(constructor_fields))})\n\t\t  : {("\n\t\t  , ".join(constructor_init))} {{}}\n")
            f.write(f"\t\t{name}(const {name}& other) = default;\n")
            f.write(f"\t\t{name}(const {c_name}& other)\n\t\t  : {name}(*reinterpret_cast<{name} const*>(&other))\n\t\t{{\n\t\t}}\n")
            f.write(f"\n\t\tconstexpr {name}& operator=({ns}{name} const& other) noexcept = default;\n")
            f.write(f"\t\tinline {name}& operator=({c_name} const& other) noexcept\n\t\t{{\n\t\t\t*this = *reinterpret_cast<{ns}{name} const*>(&other);\n\t\t\treturn *this;\n\t\t}}\n\n")
            f.write(f"\t\toperator {c_name}&() noexcept\n\t\t{{\n\t\t\treturn *reinterpret_cast<{c_name}*>(this);\n\t\t}}\n")
            f.write(f"\t\toperator const {c_name}&() const noexcept\n\t\t{{\n\t\t\treturn *reinterpret_cast<{c_name} const*>(this);\n\t\t}}\n\n")
            f.write(f"\t\tauto operator<=>({name} const& other) const = default;\n")
            f.write("\t};\n\n")

            visual_junk.append(f"\tstatic_assert(sizeof({name}) == sizeof({c_name}));\n")

        f.write("\n")
        f.write("".join(visual_junk))
        f.write("\n")

        #print(method_map)

    except Exception as e:
        print(f"Error parsing header: {e}")
        raise
    
    f.write("}\n")
    f.close()

if __name__ == "__main__":
    header_file = "../include/varyag.h"
    if not os.path.exists(header_file):
        print(f"Error: File '{header_file}' not found.")
        sys.exit(1)
    
    parse_header(header_file)
